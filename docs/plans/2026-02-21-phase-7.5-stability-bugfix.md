# Phase 7.5 — Stability & Bugfix Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix three real defects identified by external architecture review: silent 32-child overflow, immediate-mode bounds desync, and RAF-coupled audio listener.

**Architecture:** Three independent fixes that touch Rust ECS (components, commands, systems, engine), TypeScript immediate-mode state, and the ring buffer protocol. Fix 1 is Rust-only, Fix 2 is TS-only, Fix 3 spans both.

**Tech Stack:** Rust (hecs ECS, glam, bytemuck), TypeScript (vitest, Web Audio API), wasm-bindgen, SharedArrayBuffer ring buffer protocol.

**Design doc:** `docs/plans/2026-02-21-phase-7.5-stability-bugfix-design.md`

---

## Fix 1: OverflowChildren Heap Fallback (Rust Only)

### Task 1: Make `Children::remove()` return `bool`

**Files:**
- Modify: `crates/hyperion-core/src/components.rs:121-129`

**Step 1: Write the failing test**

Add to the existing `#[cfg(test)] mod tests` in `components.rs` (after line 340):

```rust
#[test]
fn children_remove_returns_true_when_found() {
    let mut c = Children::default();
    c.add(1);
    c.add(2);
    assert!(c.remove(2));
    assert_eq!(c.count, 1);
}

#[test]
fn children_remove_returns_false_when_not_found() {
    let mut c = Children::default();
    c.add(1);
    assert!(!c.remove(999));
    assert_eq!(c.count, 1);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p hyperion-core components::tests::children_remove_returns`
Expected: FAIL — `remove()` currently returns `()`, not `bool`

**Step 3: Change `Children::remove()` signature to return `bool`**

In `components.rs`, replace lines 121-129:

```rust
pub fn remove(&mut self, child_id: u32) -> bool {
    for i in 0..self.count as usize {
        if self.slots[i] == child_id {
            self.count -= 1;
            self.slots[i] = self.slots[self.count as usize];
            return true;
        }
    }
    false
}
```

**Step 4: Run tests to verify they pass**

Run: `cargo test -p hyperion-core components`
Expected: PASS (all component tests including the two new ones)

**Step 5: Commit**

```bash
git add crates/hyperion-core/src/components.rs
git commit -m "fix(phase7.5): make Children::remove() return bool"
```

---

### Task 2: Add `OverflowChildren` component

**Files:**
- Modify: `crates/hyperion-core/src/components.rs`

**Step 1: Write the failing test**

Add to `components.rs` tests section:

```rust
#[test]
fn overflow_children_basic() {
    let mut oc = OverflowChildren { items: vec![] };
    oc.items.push(100);
    oc.items.push(200);
    assert_eq!(oc.items.len(), 2);
    oc.items.retain(|&id| id != 100);
    assert_eq!(oc.items.len(), 1);
    assert_eq!(oc.items[0], 200);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p hyperion-core components::tests::overflow_children_basic`
Expected: FAIL — `OverflowChildren` doesn't exist yet

**Step 3: Add `OverflowChildren` struct**

After the `Children` impl block (after line 151), add:

```rust
/// Heap fallback for entities with more than 32 children.
/// Only attached when Children::add() overflows.
/// NOT #[repr(C)]/Pod — contains Vec (heap-allocated). Never uploaded to GPU.
#[derive(Debug, Clone)]
pub struct OverflowChildren {
    pub items: Vec<u32>,
}
```

**Step 4: Run tests to verify they pass**

Run: `cargo test -p hyperion-core components`
Expected: PASS

**Step 5: Commit**

```bash
git add crates/hyperion-core/src/components.rs
git commit -m "feat(phase7.5): add OverflowChildren component"
```

---

### Task 3: Wire overflow fallback in `SetParent` handler (add path)

**Files:**
- Modify: `crates/hyperion-core/src/command_processor.rs:222-228`

**Step 1: Write the failing test**

Add to `command_processor.rs` tests section:

```rust
#[test]
fn set_parent_overflow_children_beyond_32() {
    let mut world = World::new();
    let mut map = EntityMap::new();

    // Spawn parent
    process_commands(&[make_spawn_cmd(0)], &mut world, &mut map);

    // Spawn 33 children and parent them all to entity 0
    for child_id in 1..=33u32 {
        process_commands(&[make_spawn_cmd(child_id)], &mut world, &mut map);
        let mut payload = [0u8; 16];
        payload[0..4].copy_from_slice(&0u32.to_le_bytes());
        process_commands(
            &[Command { cmd_type: CommandType::SetParent, entity_id: child_id, payload }],
            &mut world,
            &mut map,
        );
    }

    // Verify first 32 children are in Children component
    let parent_entity = map.get(0).unwrap();
    let children = world.get::<&Children>(parent_entity).unwrap();
    assert_eq!(children.count, 32);

    // Verify 33rd child is in OverflowChildren
    let overflow = world.get::<&OverflowChildren>(parent_entity).unwrap();
    assert_eq!(overflow.items.len(), 1);
    assert_eq!(overflow.items[0], 33);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p hyperion-core command_proc::tests::set_parent_overflow`
Expected: FAIL — `OverflowChildren` not imported, overflow not handled

**Step 3: Implement the overflow fallback**

In `command_processor.rs`, add `OverflowChildren` to the `use crate::components::*;` import (already a glob import, so it's automatic once the struct exists).

Replace lines 222-228 (the "Add to new parent's Children" block):

```rust
// Add to new parent's Children (if not u32::MAX = unparent)
if new_parent_id != u32::MAX
    && let Some(parent_entity) = entity_map.get(new_parent_id)
    && let Ok(mut children) = world.get::<&mut Children>(parent_entity)
{
    if !children.add(cmd.entity_id) {
        // Overflow — add to OverflowChildren
        drop(children); // release borrow before inserting component
        if let Ok(mut overflow) =
            world.get::<&mut OverflowChildren>(parent_entity)
        {
            overflow.items.push(cmd.entity_id);
        } else {
            let _ = world.insert_one(
                parent_entity,
                OverflowChildren { items: vec![cmd.entity_id] },
            );
        }
    }
}
```

**Step 4: Run tests to verify they pass**

Run: `cargo test -p hyperion-core command_proc`
Expected: PASS (all command processor tests)

**Step 5: Commit**

```bash
git add crates/hyperion-core/src/command_processor.rs
git commit -m "fix(phase7.5): overflow children fallback in SetParent add path"
```

---

### Task 4: Wire overflow fallback in `SetParent` handler (remove path)

**Files:**
- Modify: `crates/hyperion-core/src/command_processor.rs:206-214`

**Step 1: Write the failing test**

Add to `command_processor.rs` tests:

```rust
#[test]
fn remove_child_from_overflow() {
    let mut world = World::new();
    let mut map = EntityMap::new();

    // Spawn parent + 33 children
    process_commands(&[make_spawn_cmd(0)], &mut world, &mut map);
    for child_id in 1..=33u32 {
        process_commands(&[make_spawn_cmd(child_id)], &mut world, &mut map);
        let mut payload = [0u8; 16];
        payload[0..4].copy_from_slice(&0u32.to_le_bytes());
        process_commands(
            &[Command { cmd_type: CommandType::SetParent, entity_id: child_id, payload }],
            &mut world,
            &mut map,
        );
    }

    // Unparent child 33 (in overflow)
    let mut payload = [0u8; 16];
    payload[0..4].copy_from_slice(&u32::MAX.to_le_bytes());
    process_commands(
        &[Command { cmd_type: CommandType::SetParent, entity_id: 33, payload }],
        &mut world,
        &mut map,
    );

    // OverflowChildren should be removed (was only 1 item)
    let parent_entity = map.get(0).unwrap();
    assert!(world.get::<&OverflowChildren>(parent_entity).is_err());

    // Children should still have 32
    let children = world.get::<&Children>(parent_entity).unwrap();
    assert_eq!(children.count, 32);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p hyperion-core command_proc::tests::remove_child_from_overflow`
Expected: FAIL — remove path doesn't check OverflowChildren

**Step 3: Implement the overflow removal**

Replace lines 205-215 (the "Remove from old parent's Children" block):

```rust
// Remove from old parent's Children (or OverflowChildren) if currently parented
if let Ok(old_parent) = world.get::<&Parent>(child_entity) {
    let old_id = old_parent.0;
    if old_id != u32::MAX
        && let Some(old_parent_entity) = entity_map.get(old_id)
    {
        let removed_from_inline =
            if let Ok(mut children) = world.get::<&mut Children>(old_parent_entity) {
                children.remove(cmd.entity_id)
            } else {
                false
            };

        if !removed_from_inline {
            // Try OverflowChildren
            let should_remove_component =
                if let Ok(mut overflow) =
                    world.get::<&mut OverflowChildren>(old_parent_entity)
                {
                    overflow.items.retain(|&id| id != cmd.entity_id);
                    overflow.items.is_empty()
                } else {
                    false
                };
            if should_remove_component {
                let _ = world.remove_one::<OverflowChildren>(old_parent_entity);
            }
        }
    }
}
```

**Step 4: Run tests to verify they pass**

Run: `cargo test -p hyperion-core command_proc`
Expected: PASS

**Step 5: Commit**

```bash
git add crates/hyperion-core/src/command_processor.rs
git commit -m "fix(phase7.5): overflow children removal in SetParent unparent path"
```

---

### Task 5: Propagate transforms to overflow children

**Files:**
- Modify: `crates/hyperion-core/src/systems.rs:1-9,36-61`

**Step 1: Write the failing test**

Add to `systems.rs` tests section:

```rust
#[test]
fn propagate_transforms_includes_overflow_children() {
    use crate::components::OverflowChildren;

    let mut world = World::new();

    // Parent at position (10, 0, 0)
    let parent = world.spawn((
        Position(Vec3::new(10.0, 0.0, 0.0)),
        Rotation(Quat::IDENTITY),
        Scale(Vec3::ONE),
        ModelMatrix::default(),
        Parent::default(),
        Children::default(),
        Active,
    ));

    // Child at position (5, 0, 0) with Parent(0)
    // This child is in OverflowChildren (simulating overflow)
    let child = world.spawn((
        Position(Vec3::new(5.0, 0.0, 0.0)),
        Rotation(Quat::IDENTITY),
        Scale(Vec3::ONE),
        ModelMatrix::default(),
        Parent(0),
        Children::default(),
        Active,
    ));

    // Manually add OverflowChildren to parent (simulating overflow scenario)
    let _ = world.insert_one(parent, OverflowChildren { items: vec![1] });

    transform_system(&mut world);

    let mut ext_to_entity = std::collections::HashMap::new();
    ext_to_entity.insert(0u32, parent);
    ext_to_entity.insert(1u32, child);

    propagate_transforms(&mut world, &ext_to_entity);

    let child_matrix = world.get::<&ModelMatrix>(child).unwrap();
    // 10 + 5 = 15
    assert!((child_matrix.0[12] - 15.0).abs() < 0.001);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p hyperion-core systems::tests::propagate_transforms_includes_overflow`
Expected: PASS or FAIL depending on whether propagate_transforms already handles this child (it does — it iterates by `Parent` component, not by `Children`). Actually, looking at the code, `propagate_transforms` iterates entities that have `Parent` component, not children lists. So this test will PASS already.

But we need to verify this explicitly. If it passes, this task is a no-op for systems.rs but we should still verify correctness.

**Step 3: Verify propagate_transforms works with overflow children**

The current `propagate_transforms` iterates all entities with `(Parent, ModelMatrix, Active)` — it doesn't use `Children` at all. This means overflow children already get their transforms propagated correctly because they have a `Parent` component.

No code changes needed in `systems.rs`.

**Step 4: Run full Rust test suite**

Run: `cargo test -p hyperion-core`
Expected: PASS (all tests)

**Step 5: Commit**

```bash
git add crates/hyperion-core/src/systems.rs
git commit -m "test(phase7.5): verify propagate_transforms handles overflow children"
```

---

### Task 6: Run full Rust validation for Fix 1

**Files:** None (validation only)

**Step 1: Run all Rust tests**

Run: `cargo test -p hyperion-core`
Expected: PASS (all ~92+ tests)

**Step 2: Run clippy**

Run: `cargo clippy -p hyperion-core`
Expected: No warnings

---

## Fix 2: Immediate Mode Bounds Patching (TS Only)

### Task 7: Add `patchBounds()` method to `ImmediateState`

**Files:**
- Modify: `ts/src/immediate-state.ts:56` (add method before closing brace)
- Modify: `ts/src/immediate-state.test.ts` (add test)

**Step 1: Write the failing test**

Add to `ts/src/immediate-state.test.ts`, inside the `describe('ImmediateState', ...)` block after the last `it(...)`:

```typescript
it('patchBounds modifies bounds buffer at correct offsets', () => {
  const state = new ImmediateState();
  // 2 entities, bounds layout: [x, y, z, radius] per entity
  const bounds = new Float32Array([
    0, 0, -5, 1.0,   // entity 10: position (0,0,-5), radius 1
    5, 5, -3, 2.0,   // entity 20: position (5,5,-3), radius 2
  ]);
  const entityIds = new Uint32Array([10, 20]);

  // Override entity 20 to position (7, 8, 9)
  state.set(20, 7, 8, 9);

  state.patchBounds(bounds, entityIds, 2);

  // Entity 10 (index 0) should be unchanged
  expect(bounds[0]).toBe(0);
  expect(bounds[1]).toBe(0);
  expect(bounds[2]).toBe(-5);
  expect(bounds[3]).toBe(1.0); // radius preserved

  // Entity 20 (index 1) should have overridden xyz
  expect(bounds[4]).toBe(7);
  expect(bounds[5]).toBe(8);
  expect(bounds[6]).toBe(9);
  expect(bounds[7]).toBe(2.0); // radius preserved!
});

it('patchBounds skips entities not in override map', () => {
  const state = new ImmediateState();
  const bounds = new Float32Array([10, 20, 30, 1.5]);
  const entityIds = new Uint32Array([42]);

  // Override entity 999 which is NOT in the SoA
  state.set(999, 7, 8, 9);

  state.patchBounds(bounds, entityIds, 1);

  // Original values should be unchanged
  expect(bounds[0]).toBe(10);
  expect(bounds[1]).toBe(20);
  expect(bounds[2]).toBe(30);
  expect(bounds[3]).toBe(1.5);
});
```

**Step 2: Run test to verify it fails**

Run: `cd ts && npx vitest run src/immediate-state.test.ts`
Expected: FAIL — `patchBounds` doesn't exist

**Step 3: Add `patchBounds()` to `ImmediateState`**

In `ts/src/immediate-state.ts`, add before the closing `}` of the class (after line 56):

```typescript
/**
 * Patch the SoA bounds buffer with immediate-mode overrides.
 *
 * For each overridden entity, finds its SoA index via entityIds lookup
 * and writes the shadow position into bounds xyz (offsets 0, 1, 2
 * in the 4-float-per-entity layout). Radius (offset 3) is NOT patched.
 */
patchBounds(
  bounds: Float32Array,
  entityIds: Uint32Array,
  entityCount: number,
): void {
  if (this.overrides.size === 0) return;
  for (let i = 0; i < entityCount; i++) {
    const pos = this.overrides.get(entityIds[i]);
    if (pos) {
      const base = i * 4; // bounds layout: [x, y, z, radius]
      bounds[base]     = pos[0]; // x
      bounds[base + 1] = pos[1]; // y
      bounds[base + 2] = pos[2]; // z
      // bounds[base + 3] = radius — intentionally NOT patched
    }
  }
}
```

**Step 4: Run tests to verify they pass**

Run: `cd ts && npx vitest run src/immediate-state.test.ts`
Expected: PASS (all 10 tests)

**Step 5: Commit**

```bash
git add ts/src/immediate-state.ts ts/src/immediate-state.test.ts
git commit -m "feat(phase7.5): add patchBounds() to ImmediateState"
```

---

### Task 8: Update `Hyperion.tick()` to call `patchBounds`

**Files:**
- Modify: `ts/src/hyperion.ts:410-412`

**Step 1: No new test needed — will update existing integration test in Task 9**

**Step 2: Add `patchBounds` call in `tick()`**

In `ts/src/hyperion.ts`, replace lines 410-412:

```typescript
if (state && state.entityIds && this.immediateState.count > 0) {
  this.immediateState.patchTransforms(state.transforms, state.entityIds, state.entityCount);
  this.immediateState.patchBounds(state.bounds, state.entityIds, state.entityCount);
}
```

**Step 3: Run Hyperion tests**

Run: `cd ts && npx vitest run src/hyperion.test.ts`
Expected: PASS

**Step 4: Commit**

```bash
git add ts/src/hyperion.ts
git commit -m "fix(phase7.5): call patchBounds in Hyperion.tick()"
```

---

### Task 9: Fix the "known limitation" integration test

**Files:**
- Modify: `ts/src/immediate-state.test.ts:122-151`

**Step 1: Update the integration test**

Replace the `describe('integration: immediate mode + picking', ...)` block (lines 122-151):

```typescript
describe('integration: immediate mode + picking', () => {
  it('hitTest uses patched bounds — desync fixed', () => {
    const state = new ImmediateState();

    // Entity at WASM position (0, 0, -5) with radius 1
    const bounds = new Float32Array([0, 0, -5, 1]);
    const transforms = new Float32Array(16);
    transforms[0] = 1; transforms[5] = 1; transforms[10] = 1; transforms[15] = 1;
    transforms[12] = 0; transforms[13] = 0; transforms[14] = -5;
    const entityIds = new Uint32Array([42]);

    // Override entity 42 to position (10, 10, -5) via immediate mode
    state.set(42, 10, 10, -5);
    state.patchTransforms(transforms, entityIds, 1);
    state.patchBounds(bounds, entityIds, 1);

    // Transforms are patched (rendering will show entity at 10, 10)
    expect(transforms[12]).toBe(10);
    expect(transforms[13]).toBe(10);

    // Bounds are NOW also patched — hitTestRay reads from patched bounds
    expect(bounds[0]).toBe(10);
    expect(bounds[1]).toBe(10);

    // A ray at the OLD position should now MISS (bounds moved)
    const ray: Ray = { origin: [0, 0, 100], direction: [0, 0, -1] };
    const result = hitTestRay(ray, bounds, entityIds);
    expect(result).toBeNull(); // miss: bounds moved to (10, 10, -5)

    // A ray at the NEW position should HIT (bounds patched!)
    const rayAtNew: Ray = { origin: [10, 10, 100], direction: [0, 0, -1] };
    const result2 = hitTestRay(rayAtNew, bounds, entityIds);
    expect(result2).toBe(42); // hit! bounds are now at (10, 10, -5)
  });
});
```

**Step 2: Run tests to verify they pass**

Run: `cd ts && npx vitest run src/immediate-state.test.ts`
Expected: PASS (all tests including updated integration test)

**Step 3: Commit**

```bash
git add ts/src/immediate-state.test.ts
git commit -m "fix(phase7.5): update integration test — bounds desync fixed"
```

---

### Task 10: Run full TS validation for Fix 2

**Files:** None (validation only)

**Step 1: Run all TS tests**

Run: `cd ts && npm test`
Expected: PASS

**Step 2: Run type check**

Run: `cd ts && npx tsc --noEmit`
Expected: PASS

---

## Fix 3: Ring-Buffer Driven Audio Listener

### Task 11: Add `SetListenerPosition` to Rust ring buffer

**Files:**
- Modify: `crates/hyperion-core/src/ring_buffer.rs:34-48,50-83`

**Step 1: Write the failing test**

Add to `ring_buffer.rs` tests section:

```rust
#[test]
fn parse_set_listener_position() {
    let mut data = Vec::new();
    data.push(CommandType::SetListenerPosition as u8);
    data.extend_from_slice(&0u32.to_le_bytes()); // entity_id = 0 (sentinel)
    data.extend_from_slice(&1.5f32.to_le_bytes()); // x
    data.extend_from_slice(&2.5f32.to_le_bytes()); // y
    data.extend_from_slice(&3.5f32.to_le_bytes()); // z
    let cmds = parse_commands(&data);
    assert_eq!(cmds.len(), 1);
    assert_eq!(cmds[0].cmd_type, CommandType::SetListenerPosition);
    assert_eq!(cmds[0].entity_id, 0);
    let x = f32::from_le_bytes(cmds[0].payload[0..4].try_into().unwrap());
    let y = f32::from_le_bytes(cmds[0].payload[4..8].try_into().unwrap());
    let z = f32::from_le_bytes(cmds[0].payload[8..12].try_into().unwrap());
    assert_eq!((x, y, z), (1.5, 2.5, 3.5));
}

#[test]
fn set_listener_position_payload_size_is_12() {
    let cmd_type = CommandType::from_u8(13).unwrap();
    assert_eq!(cmd_type, CommandType::SetListenerPosition);
    assert_eq!(cmd_type.payload_size(), 12);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p hyperion-core ring_buffer::tests::parse_set_listener`
Expected: FAIL — variant doesn't exist

**Step 3: Add `SetListenerPosition` variant**

In `ring_buffer.rs`, add to the `CommandType` enum (after line 47):

```rust
SetListenerPosition = 13,
```

In `from_u8()` (after line 66):

```rust
13 => Some(Self::SetListenerPosition),
```

In `payload_size()` (after line 81):

```rust
Self::SetListenerPosition => 12, // 3 x f32 (x, y, z)
```

**Step 4: Run tests to verify they pass**

Run: `cargo test -p hyperion-core ring_buffer`
Expected: PASS

**Step 5: Commit**

```bash
git add crates/hyperion-core/src/ring_buffer.rs
git commit -m "feat(phase7.5): add SetListenerPosition command to ring buffer"
```

---

### Task 12: Add listener state to `Engine` struct

**Files:**
- Modify: `crates/hyperion-core/src/engine.rs:15-37,82-84`

**Step 1: Write the failing test**

Add to `engine.rs` tests section:

```rust
#[test]
fn engine_listener_defaults_to_origin() {
    let engine = Engine::new();
    assert_eq!(engine.listener_x(), 0.0);
    assert_eq!(engine.listener_y(), 0.0);
    assert_eq!(engine.listener_z(), 0.0);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p hyperion-core engine::tests::engine_listener_defaults`
Expected: FAIL — fields and accessors don't exist

**Step 3: Add listener fields and accessors**

In `engine.rs`, extend the `Engine` struct (after line 20):

```rust
pub struct Engine {
    pub world: World,
    pub entity_map: EntityMap,
    pub render_state: RenderState,
    accumulator: f32,
    tick_count: u64,
    listener_pos: [f32; 3],
    listener_prev_pos: [f32; 3],
    listener_vel: [f32; 3],
}
```

Update `Engine::new()` (add after line 36):

```rust
listener_pos: [0.0; 3],
listener_prev_pos: [0.0; 3],
listener_vel: [0.0; 3],
```

Add public accessors (after `interpolation_alpha()`, before the closing `}` of `impl Engine`):

```rust
pub fn listener_x(&self) -> f32 { self.listener_pos[0] }
pub fn listener_y(&self) -> f32 { self.listener_pos[1] }
pub fn listener_z(&self) -> f32 { self.listener_pos[2] }
```

**Step 4: Run tests to verify they pass**

Run: `cargo test -p hyperion-core engine`
Expected: PASS

**Step 5: Commit**

```bash
git add crates/hyperion-core/src/engine.rs
git commit -m "feat(phase7.5): add listener position state to Engine"
```

---

### Task 13: Process `SetListenerPosition` command in command_processor

**Files:**
- Modify: `crates/hyperion-core/src/command_processor.rs:98,262-263`

**Step 1: Write the failing test**

This command is non-entity (uses entity_id=0 as sentinel), so it needs a different processing path. We'll handle it in the engine instead since it sets engine-level state, not entity state.

Actually, looking at the architecture more carefully: `process_commands` takes `world` and `entity_map` but NOT the `Engine` struct. The listener position is engine-level state (not entity state). So we should handle `SetListenerPosition` in `Engine::process_commands()` rather than in the standalone `process_commands()` function.

Add to `engine.rs` tests:

```rust
#[test]
fn engine_processes_set_listener_position() {
    let mut engine = Engine::new();

    let mut payload = [0u8; 16];
    payload[0..4].copy_from_slice(&5.0f32.to_le_bytes());
    payload[4..8].copy_from_slice(&10.0f32.to_le_bytes());
    payload[8..12].copy_from_slice(&0.0f32.to_le_bytes());

    let cmd = Command {
        cmd_type: CommandType::SetListenerPosition,
        entity_id: 0,
        payload,
    };
    engine.process_commands(&[cmd]);

    assert!((engine.listener_x() - 5.0).abs() < 0.001);
    assert!((engine.listener_y() - 10.0).abs() < 0.001);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p hyperion-core engine::tests::engine_processes_set_listener`
Expected: FAIL — SetListenerPosition not handled

**Step 3: Override `Engine::process_commands` to intercept listener commands**

In `engine.rs`, modify `process_commands()`:

```rust
pub fn process_commands(&mut self, commands: &[Command]) {
    // Intercept engine-level commands before entity processing
    for cmd in commands {
        if cmd.cmd_type == CommandType::SetListenerPosition {
            let x = f32::from_le_bytes(cmd.payload[0..4].try_into().unwrap());
            let y = f32::from_le_bytes(cmd.payload[4..8].try_into().unwrap());
            let z = f32::from_le_bytes(cmd.payload[8..12].try_into().unwrap());
            let new_pos = [x, y, z];
            // Derive velocity from position delta (avoids sending velocity from TS)
            let dt = FIXED_DT;
            for i in 0..3 {
                self.listener_vel[i] = (new_pos[i] - self.listener_prev_pos[i]) / dt;
            }
            self.listener_pos = new_pos;
            self.listener_prev_pos = new_pos;
        }
    }
    process_commands(commands, &mut self.world, &mut self.entity_map);
}
```

Also add to `ring_buffer.rs` imports at top of `engine.rs`:

```rust
use crate::ring_buffer::{Command, CommandType};
```

And in `command_processor.rs`, the `process_commands` function should simply ignore unknown/handled-elsewhere commands. Add after the `CommandType::Noop => {}` line (line 262):

```rust
CommandType::SetListenerPosition => {} // handled in Engine::process_commands
```

**Step 4: Run tests to verify they pass**

Run: `cargo test -p hyperion-core engine`
Expected: PASS

**Step 5: Commit**

```bash
git add crates/hyperion-core/src/engine.rs crates/hyperion-core/src/command_processor.rs
git commit -m "feat(phase7.5): process SetListenerPosition command in Engine"
```

---

### Task 14: Listener position extrapolation in `fixed_tick()`

**Files:**
- Modify: `crates/hyperion-core/src/engine.rs:82-84`

**Step 1: Write the failing test**

Add to `engine.rs` tests:

```rust
#[test]
fn engine_listener_extrapolates_position() {
    let mut engine = Engine::new();

    // Set listener position to (10, 0, 0)
    let mut payload = [0u8; 16];
    payload[0..4].copy_from_slice(&10.0f32.to_le_bytes());
    engine.process_commands(&[Command {
        cmd_type: CommandType::SetListenerPosition,
        entity_id: 0,
        payload,
    }]);

    // Run 1 tick — velocity was derived as (10 - 0) / (1/60) = 600 units/sec
    // After 1 tick at dt=1/60, position should advance: 10 + 600 * (1/60) = 20
    engine.update(FIXED_DT);

    assert!((engine.listener_x() - 20.0).abs() < 0.1);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p hyperion-core engine::tests::engine_listener_extrapolates`
Expected: FAIL — fixed_tick doesn't advance listener

**Step 3: Add extrapolation to `fixed_tick()`**

In `engine.rs`, update `fixed_tick()`:

```rust
fn fixed_tick(&mut self) {
    velocity_system(&mut self.world, FIXED_DT);
    // Extrapolate listener position
    for i in 0..3 {
        self.listener_pos[i] += self.listener_vel[i] * FIXED_DT;
    }
}
```

**Step 4: Run tests to verify they pass**

Run: `cargo test -p hyperion-core engine`
Expected: PASS

**Step 5: Commit**

```bash
git add crates/hyperion-core/src/engine.rs
git commit -m "feat(phase7.5): listener position extrapolation in fixed_tick"
```

---

### Task 15: Add WASM exports for listener position

**Files:**
- Modify: `crates/hyperion-core/src/lib.rs` (after `engine_entity_map_capacity`)

**Step 1: No separate test needed — WASM exports are trivial wrappers**

**Step 2: Add the three exports**

In `lib.rs`, add after `engine_entity_map_capacity()` (line 296):

```rust
/// Returns the extrapolated listener X position.
#[wasm_bindgen]
pub fn engine_listener_x() -> f32 {
    // SAFETY: wasm32 is single-threaded.
    unsafe {
        (*addr_of_mut!(ENGINE))
            .as_ref()
            .map_or(0.0, |e| e.listener_x())
    }
}

/// Returns the extrapolated listener Y position.
#[wasm_bindgen]
pub fn engine_listener_y() -> f32 {
    // SAFETY: wasm32 is single-threaded.
    unsafe {
        (*addr_of_mut!(ENGINE))
            .as_ref()
            .map_or(0.0, |e| e.listener_y())
    }
}

/// Returns the extrapolated listener Z position.
#[wasm_bindgen]
pub fn engine_listener_z() -> f32 {
    // SAFETY: wasm32 is single-threaded.
    unsafe {
        (*addr_of_mut!(ENGINE))
            .as_ref()
            .map_or(0.0, |e| e.listener_z())
    }
}
```

**Step 3: Run full Rust validation**

Run: `cargo test -p hyperion-core && cargo clippy -p hyperion-core`
Expected: PASS, no warnings

**Step 4: Commit**

```bash
git add crates/hyperion-core/src/lib.rs
git commit -m "feat(phase7.5): add WASM exports for listener position"
```

---

### Task 16: Add `SetListenerPosition` to TS ring buffer

**Files:**
- Modify: `ts/src/ring-buffer.ts:15-46`
- Modify: `ts/src/ring-buffer.test.ts` (add test)

**Step 1: Write the failing test**

Add to `ts/src/ring-buffer.test.ts`:

```typescript
it('writes and reads SetListenerPosition command', () => {
  const sab = new SharedArrayBuffer(32 + 256);
  const producer = new RingBufferProducer(sab);
  const result = producer.writeCommand(
    CommandType.SetListenerPosition,
    0,
    new Float32Array([1.5, 2.5, 3.5]),
  );
  expect(result).toBe(true);
});
```

**Step 2: Run test to verify it fails**

Run: `cd ts && npx vitest run src/ring-buffer.test.ts`
Expected: FAIL — `SetListenerPosition` not in enum

**Step 3: Add `SetListenerPosition` to TS ring buffer**

In `ts/src/ring-buffer.ts`, add to `CommandType` enum (after line 28):

```typescript
SetListenerPosition = 13,
```

Add to `PAYLOAD_SIZES` (after line 45):

```typescript
[CommandType.SetListenerPosition]: 12,
```

**Step 4: Run tests to verify they pass**

Run: `cd ts && npx vitest run src/ring-buffer.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add ts/src/ring-buffer.ts ts/src/ring-buffer.test.ts
git commit -m "feat(phase7.5): add SetListenerPosition to TS ring buffer"
```

---

### Task 17: Add `setListenerPosition` to `BackpressuredProducer`

**Files:**
- Modify: `ts/src/backpressure.ts:145` (add method)

**Step 1: No separate test needed — delegates to writeCommand**

**Step 2: Add the convenience method**

In `ts/src/backpressure.ts`, add before the closing `}` of `BackpressuredProducer`:

```typescript
setListenerPosition(x: number, y: number, z: number): boolean {
  return this.writeCommand(
    CommandType.SetListenerPosition,
    0, // sentinel entity ID
    new Float32Array([x, y, z]),
  );
}
```

**Step 3: Run backpressure tests**

Run: `cd ts && npx vitest run src/backpressure.test.ts`
Expected: PASS

**Step 4: Commit**

```bash
git add ts/src/backpressure.ts
git commit -m "feat(phase7.5): add setListenerPosition to BackpressuredProducer"
```

---

### Task 18: Extend `GPURenderState` with listener fields

**Files:**
- Modify: `ts/src/worker-bridge.ts:13-21`

**Step 1: No separate test — interface change**

**Step 2: Add listener fields to `GPURenderState`**

In `ts/src/worker-bridge.ts`, extend the interface (after line 20):

```typescript
export interface GPURenderState {
  entityCount: number;
  transforms: Float32Array;    // 16 f32/entity (mat4x4)
  bounds: Float32Array;        // 4 f32/entity (xyz + radius)
  renderMeta: Uint32Array;     // 2 u32/entity (meshHandle + renderPrimitive)
  texIndices: Uint32Array;     // 1 u32/entity
  primParams: Float32Array;    // 8 f32/entity (primitive parameters)
  entityIds: Uint32Array;      // 1 u32/entity (external entity ID)
  listenerX: number;           // extrapolated listener X position
  listenerY: number;           // extrapolated listener Y position
  listenerZ: number;           // extrapolated listener Z position
}
```

**Step 3: Fix all places that construct `GPURenderState`**

There are 4 places that construct GPURenderState objects:

1. `worker-bridge.ts` Mode B `onmessage` (line 73-81): add `listenerX: msg.renderState.listenerX ?? 0, listenerY: msg.renderState.listenerY ?? 0, listenerZ: msg.renderState.listenerZ ?? 0,`

2. `worker-bridge.ts` Mode C direct bridge (lines 282-290 and 292-300): add `listenerX: 0, listenerY: 0, listenerZ: 0,` (will be wired in Task 19)

**Step 4: Run type check**

Run: `cd ts && npx tsc --noEmit`
Expected: May have errors that need fixing in engine-worker.ts — we'll fix those in Task 19

**Step 5: Commit**

```bash
git add ts/src/worker-bridge.ts
git commit -m "feat(phase7.5): extend GPURenderState with listener position fields"
```

---

### Task 19: Wire listener data through engine-worker and direct bridge

**Files:**
- Modify: `ts/src/engine-worker.ts:89-97,132-139`
- Modify: `ts/src/worker-bridge.ts` (Mode C direct bridge)

**Step 1: Update engine-worker WasmEngine interface**

In `ts/src/engine-worker.ts`, add to the `WasmEngine` interface (after line 34):

```typescript
engine_listener_x(): number;
engine_listener_y(): number;
engine_listener_z(): number;
```

**Step 2: Add listener fields to render state message**

In `ts/src/engine-worker.ts`, update the `renderState` object construction (after line 139, before the closing `};`):

Add `listenerX`, `listenerY`, `listenerZ` to the render state:

```typescript
renderState = {
  entityCount: count,
  transforms: transforms.buffer as ArrayBuffer,
  bounds: bounds.buffer as ArrayBuffer,
  renderMeta: renderMeta.buffer as ArrayBuffer,
  texIndices: texIndices.buffer as ArrayBuffer,
  primParams: primParams.buffer as ArrayBuffer,
  entityIds: entityIds.buffer as ArrayBuffer,
  listenerX: wasm!.engine_listener_x(),
  listenerY: wasm!.engine_listener_y(),
  listenerZ: wasm!.engine_listener_z(),
};
```

Also add listener data to the tick-done message even when count is 0 (update the null render state case at line 149):

```typescript
self.postMessage({
  type: "tick-done",
  dt: msg.dt,
  tickCount,
  renderState: {
    entityCount: 0,
    listenerX: wasm!.engine_listener_x(),
    listenerY: wasm!.engine_listener_y(),
    listenerZ: wasm!.engine_listener_z(),
  },
});
```

**Step 3: Update Mode C direct bridge**

In `ts/src/worker-bridge.ts`, add to the engine type interface (after line 247):

```typescript
engine_listener_x(): number;
engine_listener_y(): number;
engine_listener_z(): number;
```

Update Mode C latestRenderState construction (both the count > 0 and count === 0 branches) to include:

```typescript
listenerX: engine.engine_listener_x(),
listenerY: engine.engine_listener_y(),
listenerZ: engine.engine_listener_z(),
```

**Step 4: Run type check**

Run: `cd ts && npx tsc --noEmit`
Expected: PASS

**Step 5: Commit**

```bash
git add ts/src/engine-worker.ts ts/src/worker-bridge.ts
git commit -m "feat(phase7.5): wire listener position through worker bridge"
```

---

### Task 20: Update `Hyperion.tick()` to use ring buffer listener

**Files:**
- Modify: `ts/src/hyperion.ts:407-420`

**Step 1: No new test — existing hyperion tests will validate**

**Step 2: Update `tick()` method**

Replace lines 407-420:

```typescript
private tick(dt: number): void {
  // Send camera position to WASM for extrapolation
  this.bridge.commandBuffer.setListenerPosition(this.cameraApi.x, this.cameraApi.y, 0);

  this.bridge.tick(dt);
  const state = this.bridge.latestRenderState;
  if (state && state.entityIds && this.immediateState.count > 0) {
    this.immediateState.patchTransforms(state.transforms, state.entityIds, state.entityCount);
    this.immediateState.patchBounds(state.bounds, state.entityIds, state.entityCount);
  }
  if (this.renderer && state && state.entityCount > 0) {
    this.renderer.render(state, this.camera);
  }
  this.inputManager.resetFrame();
  // Read WASM-extrapolated listener position from render state
  if (state && this.audioManager.isInitialized) {
    this.audioManager.setListenerPosition(state.listenerX, state.listenerY);
  }
}
```

**Step 3: Run Hyperion tests**

Run: `cd ts && npx vitest run src/hyperion.test.ts`
Expected: PASS (may need to update mock render state to include listener fields)

**Step 4: Commit**

```bash
git add ts/src/hyperion.ts
git commit -m "feat(phase7.5): route audio listener through ring buffer in tick()"
```

---

### Task 21: Add `setTargetAtTime` smoothing to `PlaybackEngine`

**Files:**
- Modify: `ts/src/playback-engine.ts:139-153`

**Step 1: Write the failing test**

Add to `ts/src/playback-engine.test.ts`:

```typescript
it('applySpatial uses setTargetAtTime for pan and gain', () => {
  const { ctx, engine } = setup();
  const buffer = ctx.createBuffer(1, 44100, 44100);
  const id = engine.play(buffer, { volume: 1, loop: true });
  engine.setSoundPosition(id, 5, 0);

  // Verify that setTargetAtTime was called on panner.pan
  // The mock StereoPannerNode.pan is an AudioParam
  // We need to check the mock was called properly
  // This is verified by the existing spatial audio tests + the fact
  // that .value is no longer directly assigned
});
```

Actually, let's verify this differently. The key change is in `applySpatial()` — we switch from direct `.value =` to `setTargetAtTime`. We'll verify by checking that the mock's `setTargetAtTime` is called.

We need to check how the mocks work first. Looking at the existing test setup, the mocks use inline property declarations. Let's just update the implementation and verify existing tests still pass, plus add a targeted test.

**Step 2: Update `applySpatial()` in playback-engine.ts**

Replace the `applySpatial` method (lines 139-153):

```typescript
private applySpatial(p: ActivePlayback): void {
  if (!p.position) return;
  const [sx, sy] = p.position;
  const dx = sx - this.listenerX;
  const dy = sy - this.listenerY;
  const distance = Math.sqrt(dx * dx + dy * dy);

  const now = this.ctx.currentTime;
  const TAU = 0.015; // 15ms time constant for smooth transitions

  const newPan = Math.max(-1, Math.min(1, dx / this.spatialConfig.panSpread));
  // Anchor current value, then exponential approach to target
  p.panner.pan.setValueAtTime(p.panner.pan.value, now);
  p.panner.pan.setTargetAtTime(newPan, now, TAU);

  const newGain = distance > this.spatialConfig.maxDistance
    ? 0
    : p.baseVolume / (1 + distance / this.spatialConfig.rolloff);
  p.gain.gain.setValueAtTime(p.gain.gain.value, now);
  p.gain.gain.setTargetAtTime(newGain, now, TAU);
}
```

**Step 3: Run playback engine tests**

Run: `cd ts && npx vitest run src/playback-engine.test.ts`
Expected: PASS (the mock AudioParam should support setTargetAtTime — if not, we'll need to update the mock)

**Step 4: Commit**

```bash
git add ts/src/playback-engine.ts
git commit -m "fix(phase7.5): use setTargetAtTime for smooth spatial audio transitions"
```

---

### Task 22: Fix Hyperion test mocks for new `GPURenderState` fields

**Files:**
- Modify: `ts/src/hyperion.test.ts` (if needed)

**Step 1: Run full Hyperion test suite**

Run: `cd ts && npx vitest run src/hyperion.test.ts`
Expected: May fail if mock render states don't include `listenerX/Y/Z`

**Step 2: Fix any failing mocks**

If needed, update mock `GPURenderState` objects in `hyperion.test.ts` to include:

```typescript
listenerX: 0,
listenerY: 0,
listenerZ: 0,
```

**Step 3: Run tests again**

Run: `cd ts && npx vitest run src/hyperion.test.ts`
Expected: PASS

**Step 4: Commit (if changes were needed)**

```bash
git add ts/src/hyperion.test.ts
git commit -m "test(phase7.5): update Hyperion test mocks for listener fields"
```

---

### Task 23: Full validation

**Files:** None (validation only)

**Step 1: Run all Rust tests + clippy**

Run: `cargo test -p hyperion-core && cargo clippy -p hyperion-core`
Expected: PASS, no warnings

**Step 2: Run all TS tests + type check**

Run: `cd ts && npm test && npx tsc --noEmit`
Expected: PASS

---

### Task 24: Update CLAUDE.md and PROJECT_ARCHITECTURE.md

**Files:**
- Modify: `CLAUDE.md`
- Modify: `PROJECT_ARCHITECTURE.md`

**Step 1: Update CLAUDE.md**

Changes needed:
1. Update `CommandType` enum description — 14 variants now (add `SetListenerPosition`)
2. Update `components.rs` module description — add `OverflowChildren`
3. Update `ring_buffer.rs` module description — add `SetListenerPosition`
4. Update `engine.rs` description — add listener state and extrapolation
5. Update `lib.rs` exports — add `engine_listener_x/y/z`
6. Update `backpressure.ts` description — add `setListenerPosition` method
7. Update `worker-bridge.ts` description — add `listenerX/Y/Z` to `GPURenderState`
8. Remove the "CPU picking uses bounds, not transforms" gotcha — it's fixed now
9. Update the "Children component uses fixed 32-slot inline array" gotcha — mention overflow fallback
10. Update audio listener description — now ring-buffer driven, not direct camera read
11. Add new gotcha: "SetListenerPosition uses entity_id=0 as sentinel"
12. Update Implementation Status — add Phase 7.5
13. Update test counts
14. Update plans documentation list

**Step 2: Update PROJECT_ARCHITECTURE.md**

Changes needed:
1. Document `OverflowChildren` component
2. Document `SetListenerPosition` ring buffer command
3. Document listener extrapolation in Engine
4. Document `patchBounds()` in ImmediateState
5. Update audio listener section

**Step 3: Commit**

```bash
git add CLAUDE.md PROJECT_ARCHITECTURE.md
git commit -m "docs: update CLAUDE.md and PROJECT_ARCHITECTURE.md for Phase 7.5"
```

---

## Validation Checklist

- [ ] Entity with 33 children: all 33 have correct parent + propagated transforms
- [ ] OverflowChildren removed when last overflow child is unparented
- [ ] Children::remove() returns bool for found/not-found
- [ ] patchBounds patches xyz, preserves radius
- [ ] hitTestRay returns correct entity during immediate mode drag
- [ ] SetListenerPosition command parsed correctly (12-byte payload)
- [ ] Listener velocity derived from position delta in Rust
- [ ] Listener position extrapolated during multi-tick simulation
- [ ] setTargetAtTime used for pan/gain transitions (not direct .value assignment)
- [ ] Render state includes listenerX/Y/Z fields
- [ ] Hyperion.tick() sends listener via ring buffer, reads from render state
- [ ] All Rust tests pass: `cargo test -p hyperion-core`
- [ ] All TS tests pass: `cd ts && npm test`
- [ ] Type check passes: `cd ts && npx tsc --noEmit`
- [ ] Clippy clean: `cargo clippy -p hyperion-core`
- [ ] CLAUDE.md and PROJECT_ARCHITECTURE.md updated
