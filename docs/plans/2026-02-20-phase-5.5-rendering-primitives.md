# Phase 5.5: Rendering Primitives Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Extend the rendering pipeline from quad-only to multi-primitive (lines, text, gradients, box shadows) with FXAA/tonemapping post-processing and JFA selection outlines.

**Architecture:** Multi-pipeline ForwardPass with per-primitive-type GPU pipelines, driven by stream-compacted per-type index arrays from an extended CullPass. New render passes (FXAATonemapPass, JFA passes) slot into the existing RenderGraph DAG as optional passes with dead-pass culling. A new SoA buffer (`PrimitiveParams`, 8 f32/entity) carries per-primitive configuration to the GPU. All primitives reuse the unit quad geometry with type-specific vertex/fragment shaders.

**Tech Stack:** TypeScript, WGSL compute+render shaders, Rust/WASM (`hyperion-core`), WebGPU, vitest

**Key numbers:**
- 6 primitive types: Quad(0), Line(1), SDFGlyph(2), BezierPath(3), Gradient(4), BoxShadow(5)
- PrimitiveParams buffer: 8 f32/entity = 32 bytes/entity (100k entities = 3.2 MB)
- Multi-type visible-indices: 6 regions × MAX_ENTITIES = 2.4 MB (up from 400 KB)
- Multi-type indirect-args: 6 × 5 u32 = 120 bytes (up from 20 bytes)

---

## Part 1: PrimitiveParams Infrastructure (Rust)

### Task 1: Add PrimitiveParams component

**Files:**
- Modify: `crates/hyperion-core/src/components.rs`

**Step 1: Write the failing test**

Add to the existing `#[cfg(test)] mod tests` block in `components.rs`:

```rust
#[test]
fn primitive_params_is_pod_and_default_zero() {
    let pp = PrimitiveParams::default();
    assert_eq!(pp.0, [0.0f32; 8]);
    let bytes: &[u8] = bytemuck::bytes_of(&pp);
    assert_eq!(bytes.len(), 32);
    assert!(bytes.iter().all(|&b| b == 0));
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p hyperion-core primitive_params_is_pod`
Expected: FAIL — `PrimitiveParams` not found

**Step 3: Write minimal implementation**

Add to `components.rs` after the `RenderPrimitive` definition:

```rust
/// Per-entity parameters interpreted by the active RenderPrimitive shader.
/// 8 f32 (32 bytes) — meaning depends on primitive type:
///   Line: [startX, startY, endX, endY, width, dashLen, gapLen, _pad]
///   SDFGlyph: [atlasU0, atlasV0, atlasU1, atlasV1, screenPxRange, _pad, _pad, _pad]
///   Gradient: [type, angle, stop0pos, stop0r, stop0g, stop0b, stop1pos, stop1r]
///   BoxShadow: [rectW, rectH, cornerRadius, blur, colorR, colorG, colorB, colorA]
#[derive(Debug, Clone, Copy, PartialEq)]
#[repr(C)]
pub struct PrimitiveParams(pub [f32; 8]);

// SAFETY: PrimitiveParams is #[repr(C)] with only f32 fields — trivially Pod.
unsafe impl bytemuck::Pod for PrimitiveParams {}
unsafe impl bytemuck::Zeroable for PrimitiveParams {}

impl Default for PrimitiveParams {
    fn default() -> Self {
        Self([0.0; 8])
    }
}
```

**Step 4: Run test to verify it passes**

Run: `cargo test -p hyperion-core primitive_params_is_pod`
Expected: PASS

**Step 5: Commit**

```bash
git add crates/hyperion-core/src/components.rs
git commit -m "feat(phase5.5): add PrimitiveParams component (8×f32, Pod)"
```

---

### Task 2: Add SetPrimParams ring buffer commands

**Files:**
- Modify: `crates/hyperion-core/src/ring_buffer.rs`

**Step 1: Write the failing test**

Add to `ring_buffer.rs` test module:

```rust
#[test]
fn set_prim_params_0_round_trip() {
    let cmd_type = CommandType::from_u8(11).unwrap();
    assert_eq!(cmd_type, CommandType::SetPrimParams0);
    assert_eq!(cmd_type.payload_size(), 16);
}

#[test]
fn set_prim_params_1_round_trip() {
    let cmd_type = CommandType::from_u8(12).unwrap();
    assert_eq!(cmd_type, CommandType::SetPrimParams1);
    assert_eq!(cmd_type.payload_size(), 16);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p hyperion-core set_prim_params`
Expected: FAIL — variants don't exist

**Step 3: Write minimal implementation**

In `ring_buffer.rs`, extend the `CommandType` enum:

```rust
pub enum CommandType {
    Noop = 0,
    SpawnEntity = 1,
    DespawnEntity = 2,
    SetPosition = 3,
    SetRotation = 4,
    SetScale = 5,
    SetVelocity = 6,
    SetTextureLayer = 7,
    SetMeshHandle = 8,
    SetRenderPrimitive = 9,
    SetParent = 10,
    SetPrimParams0 = 11,   // params[0..3], 4 × f32 = 16 bytes
    SetPrimParams1 = 12,   // params[4..7], 4 × f32 = 16 bytes
}
```

Update `from_u8`:
```rust
11 => Some(Self::SetPrimParams0),
12 => Some(Self::SetPrimParams1),
```

Update `payload_size`:
```rust
Self::SetPrimParams0 | Self::SetPrimParams1 => 16, // 4 × f32
```

**Step 4: Run test to verify it passes**

Run: `cargo test -p hyperion-core set_prim_params`
Expected: PASS

**Step 5: Commit**

```bash
git add crates/hyperion-core/src/ring_buffer.rs
git commit -m "feat(phase5.5): add SetPrimParams0/1 ring buffer commands"
```

---

### Task 3: Process PrimitiveParams commands in ECS

**Files:**
- Modify: `crates/hyperion-core/src/command_processor.rs`

**Step 1: Write the failing test**

Add to `command_processor.rs` test module:

```rust
#[test]
fn process_set_prim_params() {
    let mut world = World::new();
    let mut entity_map = EntityMap::new();

    // Spawn an entity first
    let spawn_cmd = Command { cmd_type: CommandType::SpawnEntity, entity_id: 0, payload: [0; 16] };
    process_commands(&[spawn_cmd], &mut world, &mut entity_map);

    // Set params 0-3
    let mut payload0 = [0u8; 16];
    payload0[0..4].copy_from_slice(&1.0f32.to_le_bytes());
    payload0[4..8].copy_from_slice(&2.0f32.to_le_bytes());
    payload0[8..12].copy_from_slice(&3.0f32.to_le_bytes());
    payload0[12..16].copy_from_slice(&4.0f32.to_le_bytes());

    let cmd0 = Command { cmd_type: CommandType::SetPrimParams0, entity_id: 0, payload: payload0 };
    process_commands(&[cmd0], &mut world, &mut entity_map);

    let entity = entity_map.get(0).unwrap();
    let pp = world.get::<&PrimitiveParams>(entity).unwrap();
    assert_eq!(pp.0[0], 1.0);
    assert_eq!(pp.0[1], 2.0);
    assert_eq!(pp.0[2], 3.0);
    assert_eq!(pp.0[3], 4.0);

    // Set params 4-7
    let mut payload1 = [0u8; 16];
    payload1[0..4].copy_from_slice(&5.0f32.to_le_bytes());
    payload1[4..8].copy_from_slice(&6.0f32.to_le_bytes());
    payload1[8..12].copy_from_slice(&7.0f32.to_le_bytes());
    payload1[12..16].copy_from_slice(&8.0f32.to_le_bytes());

    let cmd1 = Command { cmd_type: CommandType::SetPrimParams1, entity_id: 0, payload: payload1 };
    process_commands(&[cmd1], &mut world, &mut entity_map);

    let pp = world.get::<&PrimitiveParams>(entity).unwrap();
    assert_eq!(pp.0[4], 5.0);
    assert_eq!(pp.0[5], 6.0);
    assert_eq!(pp.0[6], 7.0);
    assert_eq!(pp.0[7], 8.0);
    // Params 0-3 should still be intact
    assert_eq!(pp.0[0], 1.0);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p hyperion-core process_set_prim_params`
Expected: FAIL — `PrimitiveParams` not in spawn bundle, no command handler

**Step 3: Write minimal implementation**

In `command_processor.rs`:

1. Add `PrimitiveParams` to the spawn bundle:
```rust
CommandType::SpawnEntity => {
    let entity = world.spawn((
        Position::default(),
        Rotation::default(),
        Scale::default(),
        Velocity::default(),
        ModelMatrix::default(),
        BoundingRadius::default(),
        TextureLayerIndex::default(),
        MeshHandle::default(),
        RenderPrimitive::default(),
        PrimitiveParams::default(),
        Parent::default(),
        Children::default(),
        Active,
    ));
    entity_map.insert(cmd.entity_id, entity);
}
```

2. Add command handlers (after `SetParent` match arm):
```rust
CommandType::SetPrimParams0 => {
    if let Some(entity) = entity_map.get(cmd.entity_id) {
        let p0 = f32::from_le_bytes(cmd.payload[0..4].try_into().unwrap());
        let p1 = f32::from_le_bytes(cmd.payload[4..8].try_into().unwrap());
        let p2 = f32::from_le_bytes(cmd.payload[8..12].try_into().unwrap());
        let p3 = f32::from_le_bytes(cmd.payload[12..16].try_into().unwrap());
        if let Ok(mut pp) = world.get::<&mut PrimitiveParams>(entity) {
            pp.0[0] = p0;
            pp.0[1] = p1;
            pp.0[2] = p2;
            pp.0[3] = p3;
        }
    }
}

CommandType::SetPrimParams1 => {
    if let Some(entity) = entity_map.get(cmd.entity_id) {
        let p4 = f32::from_le_bytes(cmd.payload[0..4].try_into().unwrap());
        let p5 = f32::from_le_bytes(cmd.payload[4..8].try_into().unwrap());
        let p6 = f32::from_le_bytes(cmd.payload[8..12].try_into().unwrap());
        let p7 = f32::from_le_bytes(cmd.payload[12..16].try_into().unwrap());
        if let Ok(mut pp) = world.get::<&mut PrimitiveParams>(entity) {
            pp.0[4] = p4;
            pp.0[5] = p5;
            pp.0[6] = p6;
            pp.0[7] = p7;
        }
    }
}
```

**Step 4: Run test to verify it passes**

Run: `cargo test -p hyperion-core process_set_prim_params`
Expected: PASS

**Step 5: Commit**

```bash
git add crates/hyperion-core/src/command_processor.rs
git commit -m "feat(phase5.5): process SetPrimParams0/1 commands in ECS"
```

---

### Task 4: Extend collect_gpu for PrimitiveParams + WASM exports

**Files:**
- Modify: `crates/hyperion-core/src/render_state.rs`
- Modify: `crates/hyperion-core/src/lib.rs`

**Step 1: Write the failing test**

Add to `render_state.rs` test module:

```rust
#[test]
fn collect_gpu_includes_prim_params() {
    let mut world = World::new();
    let mut pp = PrimitiveParams::default();
    pp.0[0] = 42.0;
    pp.0[7] = 99.0;

    world.spawn((
        Position(glam::Vec3::ZERO),
        ModelMatrix([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]),
        BoundingRadius(1.0),
        TextureLayerIndex(0),
        MeshHandle(0),
        RenderPrimitive(0),
        pp,
        Active,
    ));

    let mut rs = RenderState::new();
    rs.collect_gpu(&world);

    assert_eq!(rs.gpu_entity_count(), 1);
    let params = rs.gpu_prim_params();
    assert_eq!(params.len(), 8); // 8 f32 per entity
    assert_eq!(params[0], 42.0);
    assert_eq!(params[7], 99.0);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p hyperion-core collect_gpu_includes_prim_params`
Expected: FAIL — `gpu_prim_params` method not found

**Step 3: Write minimal implementation**

In `render_state.rs`:

1. Add field to `RenderState`:
```rust
pub struct RenderState {
    // ... existing fields ...
    gpu_prim_params: Vec<f32>,   // 8 f32/entity (primitive-specific parameters)
    // ... rest ...
}
```

2. Initialize in `new()`:
```rust
gpu_prim_params: Vec::new(),
```

3. In `collect_gpu()`, add PrimitiveParams to the query and buffer:
```rust
// Add PrimitiveParams to the query tuple
for (pos, matrix, radius, tex, mesh, prim, pp, _active) in world
    .query::<(
        &Position,
        &ModelMatrix,
        &BoundingRadius,
        &TextureLayerIndex,
        &MeshHandle,
        &RenderPrimitive,
        &PrimitiveParams,
        &Active,
    )>()
    .iter()
{
    // ... existing buffer fills ...

    // Buffer E: PrimitiveParams (8 f32)
    self.gpu_prim_params.extend_from_slice(&pp.0);

    self.gpu_count += 1;
}
```

Also clear and reserve in `collect_gpu()`:
```rust
self.gpu_prim_params.clear();
// ...
self.gpu_prim_params.reserve(hint * 8);
```

Add debug assertion:
```rust
debug_assert_eq!(self.gpu_count as usize * 8, self.gpu_prim_params.len());
```

4. Add accessor methods:
```rust
pub fn gpu_prim_params(&self) -> &[f32] {
    &self.gpu_prim_params
}

pub fn gpu_prim_params_ptr(&self) -> *const f32 {
    if self.gpu_prim_params.is_empty() {
        std::ptr::null()
    } else {
        self.gpu_prim_params.as_ptr()
    }
}

pub fn gpu_prim_params_f32_len(&self) -> u32 {
    self.gpu_prim_params.len() as u32
}
```

5. Update `shrink_to_fit()`:
```rust
pub fn shrink_to_fit(&mut self) {
    // ... existing shrinks ...
    self.gpu_prim_params.shrink_to_fit();
}
```

6. Add WASM exports in `lib.rs`:
```rust
/// Pointer to the prim params buffer (8 f32 per entity).
#[wasm_bindgen]
pub fn engine_gpu_prim_params_ptr() -> *const f32 {
    // SAFETY: wasm32 is single-threaded.
    unsafe {
        (*addr_of_mut!(ENGINE))
            .as_ref()
            .map_or(std::ptr::null(), |e| e.render_state.gpu_prim_params_ptr())
    }
}

/// Number of f32 values in the prim params buffer.
#[wasm_bindgen]
pub fn engine_gpu_prim_params_f32_len() -> u32 {
    // SAFETY: wasm32 is single-threaded.
    unsafe {
        (*addr_of_mut!(ENGINE))
            .as_ref()
            .map_or(0, |e| e.render_state.gpu_prim_params_f32_len())
    }
}
```

**Step 4: Run tests to verify they pass**

Run: `cargo test -p hyperion-core collect_gpu_includes_prim_params && cargo test -p hyperion-core render_state`
Expected: PASS

**Step 5: Commit**

```bash
git add crates/hyperion-core/src/render_state.rs crates/hyperion-core/src/lib.rs
git commit -m "feat(phase5.5): add gpu_prim_params SoA buffer + WASM exports"
```

---

### Task 5: Run full Rust validation

**Step 1: Run all Rust tests + clippy**

Run: `cargo test -p hyperion-core && cargo clippy -p hyperion-core`
Expected: All 85+ tests PASS, no clippy warnings

**Step 2: Commit if needed**

Fix any issues, then:
```bash
git commit -m "fix(phase5.5): address clippy warnings from Part 1"
```

---

## Part 2: PrimitiveParams Infrastructure (TypeScript)

### Task 6: Add SetPrimParams commands to TS ring buffer

**Files:**
- Modify: `ts/src/ring-buffer.ts`
- Modify: `ts/src/ring-buffer.test.ts`

**Step 1: Write the failing test**

In `ts/src/ring-buffer.test.ts`, add:

```typescript
it('should write and read SetPrimParams0 command', () => {
  const buf = createRingBuffer(256);
  const prod = new RingBufferProducer(buf as SharedArrayBuffer);

  const ok = prod.setPrimParams0(42, 1.0, 2.0, 3.0, 4.0);
  expect(ok).toBe(true);

  const data = extractUnread(buf);
  expect(data.byteLength).toBe(1 + 4 + 16); // cmd + entityId + 4×f32
  const view = new DataView(data.buffer, data.byteOffset);
  expect(view.getUint8(0)).toBe(11); // SetPrimParams0
  expect(view.getUint32(1, true)).toBe(42);
  expect(view.getFloat32(5, true)).toBeCloseTo(1.0);
  expect(view.getFloat32(9, true)).toBeCloseTo(2.0);
  expect(view.getFloat32(13, true)).toBeCloseTo(3.0);
  expect(view.getFloat32(17, true)).toBeCloseTo(4.0);
});

it('should write and read SetPrimParams1 command', () => {
  const buf = createRingBuffer(256);
  const prod = new RingBufferProducer(buf as SharedArrayBuffer);

  const ok = prod.setPrimParams1(42, 5.0, 6.0, 7.0, 8.0);
  expect(ok).toBe(true);

  const data = extractUnread(buf);
  const view = new DataView(data.buffer, data.byteOffset);
  expect(view.getUint8(0)).toBe(12); // SetPrimParams1
});
```

**Step 2: Run test to verify it fails**

Run: `cd ts && npx vitest run src/ring-buffer.test.ts`
Expected: FAIL — `setPrimParams0` not a function

**Step 3: Write minimal implementation**

In `ts/src/ring-buffer.ts`:

1. Add to `CommandType` enum:
```typescript
export const enum CommandType {
  // ... existing ...
  SetParent = 10,
  SetPrimParams0 = 11,
  SetPrimParams1 = 12,
}
```

2. Add to `PAYLOAD_SIZES`:
```typescript
[CommandType.SetPrimParams0]: 16,
[CommandType.SetPrimParams1]: 16,
```

3. Add convenience methods to `RingBufferProducer`:
```typescript
setPrimParams0(entityId: number, p0: number, p1: number, p2: number, p3: number): boolean {
  const payload = new Float32Array([p0, p1, p2, p3]);
  return this.writeCommand(CommandType.SetPrimParams0, entityId, payload);
}

setPrimParams1(entityId: number, p4: number, p5: number, p6: number, p7: number): boolean {
  const payload = new Float32Array([p4, p5, p6, p7]);
  return this.writeCommand(CommandType.SetPrimParams1, entityId, payload);
}
```

**Step 4: Run test to verify it passes**

Run: `cd ts && npx vitest run src/ring-buffer.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add ts/src/ring-buffer.ts ts/src/ring-buffer.test.ts
git commit -m "feat(phase5.5): add SetPrimParams0/1 to TS ring buffer"
```

---

### Task 7: Add PrimParams to BackpressuredProducer

**Files:**
- Modify: `ts/src/backpressure.ts`
- Modify: `ts/src/backpressure.test.ts`

**Step 1: Write the failing test**

In `ts/src/backpressure.test.ts`, add:

```typescript
it('should enqueue setPrimParams0 via BackpressuredProducer', () => {
  // Use same mock pattern as existing tests
  const mockProducer = {
    setPrimParams0: vi.fn().mockReturnValue(true),
    setPrimParams1: vi.fn().mockReturnValue(true),
    // ... include other required mocks from existing test setup ...
  };
  const bp = new BackpressuredProducer(mockProducer as any);
  bp.setPrimParams0(1, 10.0, 20.0, 30.0, 40.0);
  expect(mockProducer.setPrimParams0).toHaveBeenCalledWith(1, 10.0, 20.0, 30.0, 40.0);
});
```

**Step 2: Run test to verify it fails**

Run: `cd ts && npx vitest run src/backpressure.test.ts`
Expected: FAIL — `setPrimParams0` not a function on BackpressuredProducer

**Step 3: Write minimal implementation**

In `ts/src/backpressure.ts`, add to `BackpressuredProducer`:

```typescript
setPrimParams0(entityId: number, p0: number, p1: number, p2: number, p3: number): void {
  if (!this.producer.setPrimParams0(entityId, p0, p1, p2, p3)) {
    this.queue.enqueue({
      priority: CommandPriority.LOW,
      execute: () => this.producer.setPrimParams0(entityId, p0, p1, p2, p3),
    });
  }
}

setPrimParams1(entityId: number, p4: number, p5: number, p6: number, p7: number): void {
  if (!this.producer.setPrimParams1(entityId, p4, p5, p6, p7)) {
    this.queue.enqueue({
      priority: CommandPriority.LOW,
      execute: () => this.producer.setPrimParams1(entityId, p4, p5, p6, p7),
    });
  }
}
```

**Step 4: Run test to verify it passes**

Run: `cd ts && npx vitest run src/backpressure.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add ts/src/backpressure.ts ts/src/backpressure.test.ts
git commit -m "feat(phase5.5): add setPrimParams to BackpressuredProducer"
```

---

### Task 8: Add per-primitive API on EntityHandle

**Files:**
- Modify: `ts/src/entity-handle.ts`
- Modify: `ts/src/entity-handle.test.ts`

**Step 1: Write the failing test**

In `ts/src/entity-handle.test.ts`, add:

```typescript
describe('primitive params', () => {
  it('should set line params via fluent API', () => {
    const mockProducer = createMockProducer();
    const handle = new EntityHandle(1, mockProducer);

    handle.line(0, 0, 100, 100, 2);
    expect(mockProducer.setRenderPrimitive).toHaveBeenCalledWith(1, 1); // Line = 1
    expect(mockProducer.setPrimParams0).toHaveBeenCalledWith(1, 0, 0, 100, 100);
    expect(mockProducer.setPrimParams1).toHaveBeenCalledWith(1, 2, 0, 0, 0);
  });

  it('should set gradient params via fluent API', () => {
    const mockProducer = createMockProducer();
    const handle = new EntityHandle(1, mockProducer);

    handle.gradient(0, 45, [0, 1, 0, 0, 0.5, 0, 1, 0]);
    expect(mockProducer.setRenderPrimitive).toHaveBeenCalledWith(1, 4); // Gradient = 4
    expect(mockProducer.setPrimParams0).toHaveBeenCalled();
    expect(mockProducer.setPrimParams1).toHaveBeenCalled();
  });

  it('should set box shadow params via fluent API', () => {
    const mockProducer = createMockProducer();
    const handle = new EntityHandle(1, mockProducer);

    handle.boxShadow(100, 80, 8, 20, 0, 0, 0, 0.5);
    expect(mockProducer.setRenderPrimitive).toHaveBeenCalledWith(1, 5); // BoxShadow = 5
    expect(mockProducer.setPrimParams0).toHaveBeenCalledWith(1, 100, 80, 8, 20);
    expect(mockProducer.setPrimParams1).toHaveBeenCalledWith(1, 0, 0, 0, 0.5);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd ts && npx vitest run src/entity-handle.test.ts`
Expected: FAIL — methods don't exist

**Step 3: Write minimal implementation**

In `ts/src/entity-handle.ts`, add `RenderPrimitiveType` enum and new methods:

```typescript
/** Render primitive type enum (must match Rust RenderPrimitiveType). */
export const enum RenderPrimitiveType {
  Quad = 0,
  Line = 1,
  SDFGlyph = 2,
  BezierPath = 3,
  Gradient = 4,
  BoxShadow = 5,
}

// In EntityHandle class:

/**
 * Configure this entity as a line.
 * @param x0 start X, y0 start Y, x1 end X, y1 end Y, width line width
 */
line(x0: number, y0: number, x1: number, y1: number, width: number): this {
  this.check();
  this._producer!.setRenderPrimitive(this._id, RenderPrimitiveType.Line);
  this._producer!.setPrimParams0(this._id, x0, y0, x1, y1);
  this._producer!.setPrimParams1(this._id, width, 0, 0, 0);
  return this;
}

/**
 * Configure this entity as a gradient.
 * @param type 0=linear, 1=radial, 2=conic
 * @param angle rotation in degrees
 * @param params [stop0pos, stop0r, stop0g, stop0b, stop1pos, stop1r]
 */
gradient(type: number, angle: number, params: number[]): this {
  this.check();
  this._producer!.setRenderPrimitive(this._id, RenderPrimitiveType.Gradient);
  this._producer!.setPrimParams0(this._id, type, angle, params[0] ?? 0, params[1] ?? 0);
  this._producer!.setPrimParams1(this._id, params[2] ?? 0, params[3] ?? 0, params[4] ?? 0, params[5] ?? 0);
  return this;
}

/**
 * Configure this entity as a box shadow.
 * @param rectW width, rectH height, cornerRadius, blur
 * @param r,g,b,a shadow color
 */
boxShadow(rectW: number, rectH: number, cornerRadius: number, blur: number,
          r: number, g: number, b: number, a: number): this {
  this.check();
  this._producer!.setRenderPrimitive(this._id, RenderPrimitiveType.BoxShadow);
  this._producer!.setPrimParams0(this._id, rectW, rectH, cornerRadius, blur);
  this._producer!.setPrimParams1(this._id, r, g, b, a);
  return this;
}
```

**Step 4: Run test to verify it passes**

Run: `cd ts && npx vitest run src/entity-handle.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add ts/src/entity-handle.ts ts/src/entity-handle.test.ts
git commit -m "feat(phase5.5): add line/gradient/boxShadow fluent API on EntityHandle"
```

---

### Task 9: Wire renderMeta + primParams GPU buffers in renderer

**Files:**
- Modify: `ts/src/renderer.ts`
- Modify: `ts/src/render/render-pass.ts` (extend FrameState)
- Modify: `ts/src/worker-bridge.ts` (extend GPURenderState if needed)

**Step 1: Extend FrameState with primParams**

In `ts/src/render/render-pass.ts`, add to `FrameState`:
```typescript
export interface FrameState {
  // ... existing ...
  primParams: Float32Array;     // 8 f32/entity
}
```

**Step 2: Add GPU buffers to renderer.ts**

In `ts/src/renderer.ts`, after the existing buffer allocations:

```typescript
resources.setBuffer('render-meta', device.createBuffer({
  size: MAX_ENTITIES * 2 * 4,  // 2 u32/entity
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
}));

resources.setBuffer('prim-params', device.createBuffer({
  size: MAX_ENTITIES * 8 * 4,  // 8 f32/entity
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
}));
```

In the `render()` function, add uploads:

```typescript
// Upload render meta
const renderMetaBuf = resources.getBuffer('render-meta')!;
device.queue.writeBuffer(
  renderMetaBuf, 0,
  state.renderMeta as Uint32Array<ArrayBuffer>, 0,
  state.entityCount * 2,
);

// Upload prim params
if (state.primParams && state.primParams.length > 0) {
  const primParamsBuf = resources.getBuffer('prim-params')!;
  device.queue.writeBuffer(
    primParamsBuf, 0,
    state.primParams as Float32Array<ArrayBuffer>, 0,
    state.entityCount * 8,
  );
}
```

Add `primParams` to `FrameState` construction:
```typescript
primParams: state.primParams ?? new Float32Array(0),
```

**Step 3: Update GPURenderState**

In `ts/src/worker-bridge.ts`, add `primParams` to `GPURenderState`:
```typescript
export interface GPURenderState {
  entityCount: number;
  transforms: Float32Array;
  bounds: Float32Array;
  renderMeta: Uint32Array;
  texIndices: Uint32Array;
  primParams: Float32Array;  // NEW
}
```

Also update the direct bridge (`createDirectBridge`) and worker bridge to populate `primParams` from WASM memory using the new `engine_gpu_prim_params_ptr` and `engine_gpu_prim_params_f32_len` exports.

**Step 4: Run type check**

Run: `cd ts && npx tsc --noEmit`
Expected: PASS (no type errors)

**Step 5: Commit**

```bash
git add ts/src/renderer.ts ts/src/render/render-pass.ts ts/src/worker-bridge.ts
git commit -m "feat(phase5.5): wire renderMeta + primParams GPU buffers end-to-end"
```

---

### Task 10: Run full TS validation

**Step 1: Run all TypeScript tests + type check**

Run: `cd ts && npm test && npx tsc --noEmit`
Expected: All 175+ tests PASS, no type errors

**Step 2: Commit if needed**

---

## Part 3: Multi-Type CullPass

### Task 11: Extend cull shader for per-type grouping

**Files:**
- Modify: `ts/src/shaders/cull.wgsl`

**Step 1: Write the updated cull shader**

Replace `ts/src/shaders/cull.wgsl` with:

```wgsl
// GPU frustum culling compute shader with per-primitive-type grouping.
// Dispatched with ceil(totalEntities / 256) workgroups.
// SoA layout: separate transforms, bounds, and renderMeta buffers.

const NUM_PRIM_TYPES: u32 = 6u;

struct CullUniforms {
    frustumPlanes: array<vec4f, 6>,
    totalEntities: u32,
    maxEntitiesPerType: u32,  // MAX_ENTITIES — region size per type
    _pad1: u32,
    _pad2: u32,
};

// Per-type indirect draw args. Packed as 6 consecutive DrawIndirectArgs.
struct DrawIndirectArgs {
    indexCount: u32,
    instanceCount: atomic<u32>,
    firstIndex: u32,
    baseVertex: u32,
    firstInstance: u32,
};

@group(0) @binding(0) var<uniform> cull: CullUniforms;
@group(0) @binding(1) var<storage, read> transforms: array<mat4x4f>;
@group(0) @binding(2) var<storage, read> bounds: array<vec4f>;
@group(0) @binding(3) var<storage, read_write> visibleIndices: array<u32>;
@group(0) @binding(4) var<storage, read_write> drawArgs: array<DrawIndirectArgs, 6>;
@group(0) @binding(5) var<storage, read> renderMeta: array<u32>;  // 2 u32/entity: [mesh, prim]

@compute @workgroup_size(256)
fn cull_main(@builtin(global_invocation_id) gid: vec3u) {
    let idx = gid.x;
    if (idx >= cull.totalEntities) {
        return;
    }

    let sphere = bounds[idx];
    let center = sphere.xyz;
    let radius = sphere.w;

    // Test sphere against all 6 frustum planes.
    var visible = true;
    for (var i = 0u; i < 6u; i = i + 1u) {
        let plane = cull.frustumPlanes[i];
        let dist = dot(plane.xyz, center) + plane.w;
        if (dist < -radius) {
            visible = false;
            break;
        }
    }

    if (visible) {
        // Read primitive type from renderMeta (second u32 per entity)
        let primType = min(renderMeta[idx * 2u + 1u], NUM_PRIM_TYPES - 1u);

        // Atomic increment for this primitive type's instance count
        let slot = atomicAdd(&drawArgs[primType].instanceCount, 1u);

        // Write entity index to the correct per-type region
        let offset = primType * cull.maxEntitiesPerType;
        visibleIndices[offset + slot] = idx;
    }
}
```

**Step 2: No automated test** — WGSL shaders can't be tested headlessly. Verify shader compiles at runtime via `npm run dev` later.

**Step 3: Commit**

```bash
git add ts/src/shaders/cull.wgsl
git commit -m "feat(phase5.5): extend cull shader for per-primitive-type grouping"
```

---

### Task 12: Update CullPass for multi-type indirect args

**Files:**
- Modify: `ts/src/render/passes/cull-pass.ts`
- Modify: `ts/src/render/passes/cull-pass.test.ts`

**Step 1: Write the failing test**

In `ts/src/render/passes/cull-pass.test.ts`, update:

```typescript
it('should declare render-meta as a read dependency', () => {
  const pass = new CullPass();
  expect(pass.reads).toContain('render-meta');
});
```

**Step 2: Run test to verify it fails**

Run: `cd ts && npx vitest run src/render/passes/cull-pass.test.ts`
Expected: FAIL — reads doesn't include `render-meta`

**Step 3: Update CullPass implementation**

In `ts/src/render/passes/cull-pass.ts`:

1. Update reads:
```typescript
readonly reads = ['entity-transforms', 'entity-bounds', 'render-meta'];
```

2. Update uniform buffer size (add `maxEntitiesPerType` field):
```typescript
// CullUniforms: 6 planes × vec4f + totalEntities + maxEntitiesPerType + 2 padding = 112 bytes (unchanged)
```

3. In `setup()`, add `renderMeta` binding:
```typescript
// Add binding 5 for renderMeta
{ binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
```

And include it in the bind group entries:
```typescript
{ binding: 5, resource: { buffer: renderMetaBuffer } },
```

4. In `prepare()`, update uniform upload to include `maxEntitiesPerType`:
```typescript
// After frustum planes, write totalEntities + maxEntitiesPerType
uniformData.setUint32(96, frame.entityCount, true);  // totalEntities
uniformData.setUint32(100, MAX_ENTITIES, true);       // maxEntitiesPerType
```

5. Update indirect args reset — now 6 draw calls × 5 u32:
```typescript
// Reset all 6 indirect draw arg sets
const NUM_PRIM_TYPES = 6;
const resetData = new Uint32Array(NUM_PRIM_TYPES * 5);
for (let i = 0; i < NUM_PRIM_TYPES; i++) {
    resetData[i * 5 + 0] = 6;  // indexCount (quad = 6 indices)
    resetData[i * 5 + 1] = 0;  // instanceCount (reset, atomicAdd in shader)
    resetData[i * 5 + 2] = 0;  // firstIndex
    resetData[i * 5 + 3] = 0;  // baseVertex
    resetData[i * 5 + 4] = 0;  // firstInstance
}
device.queue.writeBuffer(indirectBuffer, 0, resetData);
```

**Step 4: Run test to verify it passes**

Run: `cd ts && npx vitest run src/render/passes/cull-pass.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add ts/src/render/passes/cull-pass.ts ts/src/render/passes/cull-pass.test.ts
git commit -m "feat(phase5.5): update CullPass for multi-type grouping with 6 indirect draw sets"
```

---

### Task 13: Resize visible-indices and indirect-args buffers

**Files:**
- Modify: `ts/src/renderer.ts`

**Step 1: Update buffer sizes**

In `ts/src/renderer.ts`:

```typescript
const NUM_PRIM_TYPES = 6;
const INDIRECT_BUFFER_SIZE = NUM_PRIM_TYPES * 5 * 4;  // 6 × 5 u32 × 4 bytes = 120 bytes

resources.setBuffer('visible-indices', device.createBuffer({
  size: NUM_PRIM_TYPES * MAX_ENTITIES * 4,  // 6 regions × 100k × u32
  usage: GPUBufferUsage.STORAGE,
}));

resources.setBuffer('indirect-args', device.createBuffer({
  size: INDIRECT_BUFFER_SIZE,
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_DST,
}));
```

**Step 2: Run type check**

Run: `cd ts && npx tsc --noEmit`
Expected: PASS

**Step 3: Commit**

```bash
git add ts/src/renderer.ts
git commit -m "feat(phase5.5): resize visible-indices (6×MAX) and indirect-args (120B) buffers"
```

---

## Part 4: Multi-Pipeline ForwardPass

### Task 14: Refactor ForwardPass for multi-pipeline dispatch

**Files:**
- Modify: `ts/src/render/passes/forward-pass.ts`

This is the largest single refactor. The ForwardPass needs:
- Multiple `GPURenderPipeline`s (one per primitive type)
- New bind group layout with `renderMeta` and `primParams` bindings
- Per-type indirect draw calls at different buffer offsets

**Step 1: Write the failing test**

In `ts/src/render/passes/forward-pass.test.ts`:

```typescript
it('should declare render-meta and prim-params as read dependencies', () => {
  const pass = new ForwardPass();
  expect(pass.reads).toContain('render-meta');
  expect(pass.reads).toContain('prim-params');
});
```

**Step 2: Run test to verify it fails**

Run: `cd ts && npx vitest run src/render/passes/forward-pass.test.ts`
Expected: FAIL

**Step 3: Refactor ForwardPass**

Replace the entire ForwardPass class. Key changes:

1. Add `render-meta` and `prim-params` to reads:
```typescript
readonly reads = ['visible-indices', 'entity-transforms', 'tex-indices', 'indirect-args', 'render-meta', 'prim-params'];
```

2. Store multiple pipelines in a `Map<number, GPURenderPipeline>`:
```typescript
private pipelines = new Map<number, GPURenderPipeline>();
```

3. Add static shader sources per type:
```typescript
static SHADER_SOURCES: Record<number, string> = {};
```

4. In `setup()`, create pipelines for each type that has a shader source:
```typescript
for (const [typeStr, source] of Object.entries(ForwardPass.SHADER_SOURCES)) {
    const type = Number(typeStr);
    const module = device.createShaderModule({ code: source });
    const pipeline = device.createRenderPipeline({
        layout: /* pipelineLayout with updated bind groups */,
        vertex: { module, entryPoint: 'vs_main', buffers: [/* unit quad */] },
        fragment: { module, entryPoint: 'fs_main', targets: [{ format }] },
        depthStencil: { format: 'depth24plus', depthWriteEnabled: true, depthCompare: 'less' },
        primitive: { topology: 'triangle-list', cullMode: 'back' },
    });
    this.pipelines.set(type, pipeline);
}
```

5. Extend bind group 0 layout with `renderMeta` and `primParams`:
```typescript
// binding 4: renderMeta (read-only-storage)
// binding 5: primParams (read-only-storage)
```

6. In `execute()`, loop over primitive types and draw each:
```typescript
for (const [primType, pipeline] of this.pipelines) {
    renderPass.setPipeline(pipeline);
    renderPass.setVertexBuffer(0, this.vertexBuffer);
    renderPass.setIndexBuffer(this.indexBuffer, 'uint16');
    renderPass.setBindGroup(0, this.bindGroup0);
    renderPass.setBindGroup(1, this.bindGroup1);
    // Each type's indirect args are at offset primType * 20 bytes (5 u32)
    renderPass.drawIndexedIndirect(this.indirectBuffer!, primType * 20);
}
```

**Step 4: Run test to verify it passes**

Run: `cd ts && npx vitest run src/render/passes/forward-pass.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add ts/src/render/passes/forward-pass.ts ts/src/render/passes/forward-pass.test.ts
git commit -m "feat(phase5.5): refactor ForwardPass for multi-pipeline per-type dispatch"
```

---

### Task 15: Update basic.wgsl for multi-type bind groups

**Files:**
- Modify: `ts/src/shaders/basic.wgsl`

Update the quad shader to include the new bindings (even though quad doesn't use primParams, the bind group layout must match):

```wgsl
// Instanced quad shader with GPU-driven visibility indirection
// and multi-tier Texture2DArray sampling.

struct CameraUniform {
    viewProjection: mat4x4f,
};

@group(0) @binding(0) var<uniform> camera: CameraUniform;
@group(0) @binding(1) var<storage, read> transforms: array<mat4x4f>;
@group(0) @binding(2) var<storage, read> visibleIndices: array<u32>;
@group(0) @binding(3) var<storage, read> texLayerIndices: array<u32>;
@group(0) @binding(4) var<storage, read> renderMeta: array<u32>;
@group(0) @binding(5) var<storage, read> primParams: array<f32>;

// Tier 0-3 texture arrays (64, 128, 256, 512 px)
@group(1) @binding(0) var tier0Tex: texture_2d_array<f32>;
@group(1) @binding(1) var tier1Tex: texture_2d_array<f32>;
@group(1) @binding(2) var tier2Tex: texture_2d_array<f32>;
@group(1) @binding(3) var tier3Tex: texture_2d_array<f32>;
@group(1) @binding(4) var texSampler: sampler;

struct VertexOutput {
    @builtin(position) clipPosition: vec4f,
    @location(0) uv: vec2f,
    @location(1) @interpolate(flat) entityIdx: u32,
    @location(2) @interpolate(flat) texTier: u32,
    @location(3) @interpolate(flat) texLayer: u32,
};

@vertex
fn vs_main(
    @location(0) position: vec3f,
    @builtin(instance_index) instanceIdx: u32,
) -> VertexOutput {
    let entityIdx = visibleIndices[instanceIdx];
    let model = transforms[entityIdx];

    let packed = texLayerIndices[entityIdx];
    let tier = packed >> 16u;
    let layer = packed & 0xFFFFu;

    var out: VertexOutput;
    out.clipPosition = camera.viewProjection * model * vec4f(position, 1.0);
    out.uv = position.xy + 0.5;
    out.entityIdx = entityIdx;
    out.texTier = tier;
    out.texLayer = layer;

    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4f {
    var texColor: vec4f;

    switch in.texTier {
        case 1u: { texColor = textureSample(tier1Tex, texSampler, in.uv, in.texLayer); }
        case 2u: { texColor = textureSample(tier2Tex, texSampler, in.uv, in.texLayer); }
        case 3u: { texColor = textureSample(tier3Tex, texSampler, in.uv, in.texLayer); }
        default: { texColor = textureSample(tier0Tex, texSampler, in.uv, in.texLayer); }
    }

    return texColor;
}
```

**Commit:**
```bash
git add ts/src/shaders/basic.wgsl
git commit -m "feat(phase5.5): update basic.wgsl with renderMeta + primParams bindings"
```

---

### Task 16: Update renderer.ts shader registration

**Files:**
- Modify: `ts/src/renderer.ts`

Register quad shader as type 0 in the multi-pipeline ForwardPass:

```typescript
ForwardPass.SHADER_SOURCES = { 0: shaderCode }; // Quad = 0
```

Remove the old `ForwardPass.SHADER_SOURCE = shaderCode;` line.

**Commit:**
```bash
git add ts/src/renderer.ts
git commit -m "feat(phase5.5): register quad shader as ForwardPass type 0"
```

---

### Task 17: Rebuild WASM and run visual smoke test

**Step 1: Rebuild WASM**

Run: `cd ts && npm run build:wasm`
Expected: SUCCESS — wasm-pack builds without errors

**Step 2: Run dev server**

Run: `cd ts && npm run dev`
Open browser at http://localhost:5173 — verify quads still render correctly.

**Step 3: Commit if any fixes needed**

---

## Part 5: Line Rendering

### Task 18: Create line WGSL shader

**Files:**
- Create: `ts/src/shaders/line.wgsl`

```wgsl
// Instanced line shader — screen-space quad expansion from line parameters.
// PrimParams layout for Line:
//   [0]=startX, [1]=startY, [2]=endX, [3]=endY, [4]=width, [5]=dashLen, [6]=gapLen, [7]=_pad

struct CameraUniform {
    viewProjection: mat4x4f,
};

@group(0) @binding(0) var<uniform> camera: CameraUniform;
@group(0) @binding(1) var<storage, read> transforms: array<mat4x4f>;
@group(0) @binding(2) var<storage, read> visibleIndices: array<u32>;
@group(0) @binding(3) var<storage, read> texLayerIndices: array<u32>;
@group(0) @binding(4) var<storage, read> renderMeta: array<u32>;
@group(0) @binding(5) var<storage, read> primParams: array<f32>;

// Texture bindings (needed for bind group compatibility, unused by lines)
@group(1) @binding(0) var tier0Tex: texture_2d_array<f32>;
@group(1) @binding(1) var tier1Tex: texture_2d_array<f32>;
@group(1) @binding(2) var tier2Tex: texture_2d_array<f32>;
@group(1) @binding(3) var tier3Tex: texture_2d_array<f32>;
@group(1) @binding(4) var texSampler: sampler;

struct VertexOutput {
    @builtin(position) clipPosition: vec4f,
    @location(0) uv: vec2f,
    @location(1) @interpolate(flat) entityIdx: u32,
    @location(2) @interpolate(flat) texTier: u32,
    @location(3) @interpolate(flat) texLayer: u32,
};

@vertex
fn vs_main(
    @location(0) position: vec3f,
    @builtin(instance_index) instanceIdx: u32,
) -> VertexOutput {
    let entityIdx = visibleIndices[instanceIdx];
    let model = transforms[entityIdx];

    // Read line params
    let base = entityIdx * 8u;
    let startX = primParams[base + 0u];
    let startY = primParams[base + 1u];
    let endX   = primParams[base + 2u];
    let endY   = primParams[base + 3u];
    let width  = primParams[base + 4u];

    // Line direction and perpendicular
    let dir = vec2f(endX - startX, endY - startY);
    let len = length(dir);
    let d = select(vec2f(1.0, 0.0), dir / len, len > 0.001);
    let perp = vec2f(-d.y, d.x);

    // Unit quad position.xy maps [-0.5, 0.5] to line segment:
    //   x: along line (0 = start, 1 = end)
    //   y: across line (-0.5 = left, 0.5 = right)
    let along = position.x + 0.5;   // [0, 1]
    let across = position.y;         // [-0.5, 0.5]

    let worldPos = vec2f(startX, startY)
        + d * along * len
        + perp * across * width;

    var out: VertexOutput;
    out.clipPosition = camera.viewProjection * model * vec4f(worldPos, 0.0, 1.0);
    out.uv = vec2f(along, across + 0.5);
    out.entityIdx = entityIdx;
    out.texTier = 0u;
    out.texLayer = 0u;

    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4f {
    // Read line params for potential dash pattern
    let base = in.entityIdx * 8u;
    let width = primParams[base + 4u];
    let dashLen = primParams[base + 5u];
    let gapLen = primParams[base + 6u];

    // Read color from texture (layer 0, tier 0 = solid white default)
    let packed = texLayerIndices[in.entityIdx];
    let tier = packed >> 16u;
    let layer = packed & 0xFFFFu;
    var color: vec4f;
    switch tier {
        case 1u: { color = textureSample(tier1Tex, texSampler, in.uv, layer); }
        case 2u: { color = textureSample(tier2Tex, texSampler, in.uv, layer); }
        case 3u: { color = textureSample(tier3Tex, texSampler, in.uv, layer); }
        default: { color = textureSample(tier0Tex, texSampler, in.uv, layer); }
    }

    // SDF dash pattern (if dashLen > 0)
    if (dashLen > 0.0) {
        let totalLen = dashLen + gapLen;
        let along = in.uv.x;
        let lineLen = length(vec2f(
            primParams[base + 2u] - primParams[base + 0u],
            primParams[base + 3u] - primParams[base + 1u]
        ));
        let pos = along * lineLen;
        let phase = pos % totalLen;
        if (phase > dashLen) {
            discard;
        }
    }

    // Anti-alias edges (SDF from line center)
    let dist = abs(in.uv.y - 0.5) * width;
    let halfWidth = width * 0.5;
    let aa = 1.0 - smoothstep(halfWidth - 1.0, halfWidth, dist);
    color.a *= aa;

    return color;
}
```

**Commit:**
```bash
git add ts/src/shaders/line.wgsl
git commit -m "feat(phase5.5): add line WGSL shader with screen-space expansion + SDF dash"
```

---

### Task 19: Register line pipeline in ForwardPass

**Files:**
- Modify: `ts/src/renderer.ts`

```typescript
import lineShaderCode from './shaders/line.wgsl?raw';

// In createRenderer:
ForwardPass.SHADER_SOURCES = {
  0: shaderCode,      // Quad
  1: lineShaderCode,  // Line
};
```

**Commit:**
```bash
git add ts/src/renderer.ts
git commit -m "feat(phase5.5): register line pipeline (type 1) in ForwardPass"
```

---

### Task 20: Visual test — lines in dev server

**Step 1: Update main.ts to spawn test lines**

Add after the existing quad spawning code in `ts/src/main.ts`:

```typescript
// Test lines
for (let i = 0; i < 10; i++) {
  engine.spawn()
    .position(0, 0, 0)
    .scale(1, 1, 1)
    .line(-200 + i * 40, -100, -200 + i * 40, 100, 2);
}
```

**Step 2: Rebuild WASM + run dev server**

Run: `cd ts && npm run build:wasm && npm run dev`
Expected: Lines visible alongside quads in the browser

**Step 3: Remove test code from main.ts, commit**

```bash
git commit -m "feat(phase5.5): verify line rendering pipeline works end-to-end"
```

---

## Part 6: FXAA + Tonemapping Post-Processing

### Task 21: Create FXAA + tonemapping WGSL shader

**Files:**
- Create: `ts/src/shaders/fxaa-tonemap.wgsl`

```wgsl
// Combined FXAA + tonemapping post-process pass.
// Full-screen triangle: vertex shader generates a quad covering the screen.

@group(0) @binding(0) var inputTex: texture_2d<f32>;
@group(0) @binding(1) var inputSampler: sampler;
@group(0) @binding(2) var<uniform> params: FxaaParams;

struct FxaaParams {
    texelSize: vec2f,     // 1.0 / resolution
    tonemapMode: u32,     // 0=none, 1=PBR-neutral, 2=ACES
    _pad: u32,
};

struct VertexOutput {
    @builtin(position) position: vec4f,
    @location(0) uv: vec2f,
};

// Full-screen triangle trick: 3 vertices cover the entire screen
@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
    var out: VertexOutput;
    // Generate full-screen triangle from vertex index
    let x = f32(i32(vertexIndex & 1u) * 4 - 1);
    let y = f32(i32(vertexIndex >> 1u) * 4 - 1);
    out.position = vec4f(x, y, 0.0, 1.0);
    out.uv = vec2f((x + 1.0) * 0.5, (1.0 - y) * 0.5);
    return out;
}

// FXAA luminance (perceptual)
fn fxaaLuma(color: vec3f) -> f32 {
    return dot(color, vec3f(0.299, 0.587, 0.114));
}

// Khronos PBR Neutral tonemapping (13 lines)
fn pbrNeutralTonemap(color: vec3f) -> vec3f {
    let startCompression = 0.8 - 0.04;
    let desaturation = 0.15;

    let x = min(color.r, min(color.g, color.b));
    let offset = select(0.04, x - 6.25 * x * x, x < 0.08);
    var c = color - offset;

    let peak = max(c.r, max(c.g, c.b));
    if (peak < startCompression) {
        return c;
    }

    let d = 1.0 - startCompression;
    let newPeak = 1.0 - d * d / (peak + d - startCompression);
    c *= newPeak / peak;

    let g = 1.0 - 1.0 / (desaturation * (peak - newPeak) + 1.0);
    return mix(c, vec3f(newPeak), g);
}

// ACES filmic tonemapping (Krzysztof Narkowicz approximation)
fn acesTonemap(x: vec3f) -> vec3f {
    let a = 2.51;
    let b = 0.03;
    let c = 2.43;
    let d = 0.59;
    let e = 0.14;
    return saturate((x * (a * x + b)) / (x * (c * x + d) + e));
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4f {
    let uv = in.uv;
    let ts = params.texelSize;

    // --- FXAA (Lottes, simplified) ---
    let rgbM  = textureSample(inputTex, inputSampler, uv).rgb;
    let rgbNW = textureSample(inputTex, inputSampler, uv + vec2f(-ts.x, -ts.y)).rgb;
    let rgbNE = textureSample(inputTex, inputSampler, uv + vec2f( ts.x, -ts.y)).rgb;
    let rgbSW = textureSample(inputTex, inputSampler, uv + vec2f(-ts.x,  ts.y)).rgb;
    let rgbSE = textureSample(inputTex, inputSampler, uv + vec2f( ts.x,  ts.y)).rgb;

    let lumaM  = fxaaLuma(rgbM);
    let lumaNW = fxaaLuma(rgbNW);
    let lumaNE = fxaaLuma(rgbNE);
    let lumaSW = fxaaLuma(rgbSW);
    let lumaSE = fxaaLuma(rgbSE);

    let lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    let lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
    let lumaRange = lumaMax - lumaMin;

    // Early exit for low contrast regions
    if (lumaRange < max(0.0312, lumaMax * 0.125)) {
        var result = rgbM;
        // Apply tonemapping
        if (params.tonemapMode == 1u) {
            result = pbrNeutralTonemap(result);
        } else if (params.tonemapMode == 2u) {
            result = acesTonemap(result);
        }
        return vec4f(result, 1.0);
    }

    // Edge direction
    let dirSwMinusNe = lumaSW - lumaNE;
    let dirSeMinusNw = lumaSE - lumaNW;
    let dir = vec2f(dirSwMinusNe + dirSeMinusNw, dirSwMinusNe - dirSeMinusNw);
    let dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * 0.25 * 0.25, 1.0 / 128.0);
    let rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    let d = clamp(dir * rcpDirMin, vec2f(-8.0), vec2f(8.0)) * ts;

    let rgbA = 0.5 * (
        textureSample(inputTex, inputSampler, uv + d * (1.0/3.0 - 0.5)).rgb +
        textureSample(inputTex, inputSampler, uv + d * (2.0/3.0 - 0.5)).rgb
    );
    let rgbB = rgbA * 0.5 + 0.25 * (
        textureSample(inputTex, inputSampler, uv + d * -0.5).rgb +
        textureSample(inputTex, inputSampler, uv + d *  0.5).rgb
    );

    let lumaB = fxaaLuma(rgbB);
    var result: vec3f;
    if (lumaB < lumaMin || lumaB > lumaMax) {
        result = rgbA;
    } else {
        result = rgbB;
    }

    // --- Tonemapping ---
    if (params.tonemapMode == 1u) {
        result = pbrNeutralTonemap(result);
    } else if (params.tonemapMode == 2u) {
        result = acesTonemap(result);
    }

    return vec4f(result, 1.0);
}
```

**Commit:**
```bash
git add ts/src/shaders/fxaa-tonemap.wgsl
git commit -m "feat(phase5.5): add FXAA + tonemapping combined post-process shader"
```

---

### Task 22: Create FXAATonemapPass

**Files:**
- Create: `ts/src/render/passes/fxaa-tonemap-pass.ts`

```typescript
import type { RenderPass, FrameState } from '../render-pass';
import type { ResourcePool } from '../resource-pool';

/**
 * Combined FXAA + tonemapping post-process pass.
 * Reads the scene from an intermediate texture, writes to swapchain.
 * Optional: dead-pass culled when not enabled.
 */
export class FXAATonemapPass implements RenderPass {
  readonly name = 'fxaa-tonemap';
  readonly reads = ['scene-hdr'];
  readonly writes = ['swapchain'];
  readonly optional = true;

  private pipeline: GPURenderPipeline | null = null;
  private bindGroup: GPUBindGroup | null = null;
  private paramBuffer: GPUBuffer | null = null;
  private sampler: GPUSampler | null = null;
  private device: GPUDevice | null = null;
  private tonemapMode: number = 0; // 0=none, 1=PBR-neutral, 2=ACES

  static SHADER_SOURCE = '';

  setTonemapMode(mode: number): void {
    this.tonemapMode = mode;
  }

  setup(device: GPUDevice, resources: ResourcePool): void {
    this.device = device;

    if (!FXAATonemapPass.SHADER_SOURCE) {
      throw new Error('FXAATonemapPass.SHADER_SOURCE must be set before setup()');
    }

    this.sampler = device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear',
    });

    this.paramBuffer = device.createBuffer({
      size: 16, // vec2f texelSize + u32 tonemapMode + u32 pad
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    const shaderModule = device.createShaderModule({ code: FXAATonemapPass.SHADER_SOURCE });
    const format = navigator.gpu.getPreferredCanvasFormat();

    const bindGroupLayout = device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'float' } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
      ],
    });

    this.pipeline = device.createRenderPipeline({
      layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
      vertex: {
        module: shaderModule,
        entryPoint: 'vs_main',
      },
      fragment: {
        module: shaderModule,
        entryPoint: 'fs_main',
        targets: [{ format }],
      },
      primitive: { topology: 'triangle-list' },
    });

    // Bind group will be created per-frame since scene-hdr texture view changes
  }

  prepare(device: GPUDevice, frame: FrameState): void {
    if (!this.paramBuffer) return;
    const data = new ArrayBuffer(16);
    const f32 = new Float32Array(data);
    const u32 = new Uint32Array(data);
    f32[0] = 1.0 / frame.canvasWidth;
    f32[1] = 1.0 / frame.canvasHeight;
    u32[2] = this.tonemapMode;
    u32[3] = 0;
    device.queue.writeBuffer(this.paramBuffer, 0, data);
  }

  execute(encoder: GPUCommandEncoder, frame: FrameState, resources: ResourcePool): void {
    if (!this.pipeline || !this.paramBuffer || !this.sampler || !this.device) return;

    const sceneHdr = resources.getTextureView('scene-hdr');
    const swapchainView = resources.getTextureView('swapchain');
    if (!sceneHdr || !swapchainView) return;

    // Recreate bind group each frame (scene-hdr view may change)
    this.bindGroup = this.device.createBindGroup({
      layout: this.pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: sceneHdr },
        { binding: 1, resource: this.sampler },
        { binding: 2, resource: { buffer: this.paramBuffer } },
      ],
    });

    const renderPass = encoder.beginRenderPass({
      colorAttachments: [{
        view: swapchainView,
        loadOp: 'clear' as GPULoadOp,
        storeOp: 'store' as GPUStoreOp,
        clearValue: { r: 0, g: 0, b: 0, a: 1 },
      }],
    });
    renderPass.setPipeline(this.pipeline);
    renderPass.setBindGroup(0, this.bindGroup);
    renderPass.draw(3); // Full-screen triangle
    renderPass.end();
  }

  resize(_w: number, _h: number): void { /* No owned textures */ }

  destroy(): void {
    this.paramBuffer?.destroy();
    this.pipeline = null;
    this.bindGroup = null;
    this.paramBuffer = null;
    this.sampler = null;
    this.device = null;
  }
}
```

**Commit:**
```bash
git add ts/src/render/passes/fxaa-tonemap-pass.ts
git commit -m "feat(phase5.5): add FXAATonemapPass (optional, dead-pass culled)"
```

---

### Task 23: Create intermediate scene-hdr texture and wire FXAA into RenderGraph

**Files:**
- Modify: `ts/src/renderer.ts`
- Modify: `ts/src/render/passes/forward-pass.ts` (ForwardPass writes to `scene-hdr` instead of `swapchain`)

**Key change:** When FXAA is enabled, ForwardPass writes to `scene-hdr` (intermediate texture), and FXAATonemapPass reads from `scene-hdr` and writes to `swapchain`. When FXAA is disabled, ForwardPass writes directly to `swapchain` (current behavior, FXAA pass is dead-pass culled).

In `renderer.ts`:
1. Create an intermediate render texture (`scene-hdr`) matching canvas size
2. Store its view in ResourcePool under `scene-hdr`
3. Create FXAATonemapPass, add to RenderGraph
4. Re-compile the graph

ForwardPass change:
```typescript
// When FXAA is active, ForwardPass writes to 'scene-hdr' instead of 'swapchain'
readonly writes = ['scene-hdr'];
```

**Note:** This requires a mechanism to toggle between `scene-hdr` and `swapchain`. The simplest approach: ForwardPass always writes to `scene-hdr`. When FXAATonemapPass is disabled (dead-pass culled), add a fallback blit pass or just change ForwardPass.writes dynamically. For simplicity in Phase 5.5: ForwardPass always writes to `scene-hdr`, and FXAA pass is always registered but with a `tonemapMode=0` (passthrough) as default.

**Commit:**
```bash
git commit -m "feat(phase5.5): wire FXAATonemapPass into RenderGraph with scene-hdr intermediate"
```

---

### Task 24: Add PostProcessing API to Hyperion facade

**Files:**
- Modify: `ts/src/hyperion.ts`

Add to `Hyperion` class:

```typescript
/** Enable or configure post-processing. */
enablePostProcessing(options: { fxaa?: boolean; tonemapping?: 'none' | 'pbr-neutral' | 'aces' }): void {
  // Delegate to the FXAATonemapPass
  // tonemapping mode: 0=none, 1=pbr-neutral, 2=aces
}
```

**Commit:**
```bash
git commit -m "feat(phase5.5): add enablePostProcessing() to Hyperion facade"
```

---

### Task 25: Write FXAA tests

**Files:**
- Create: `ts/src/render/passes/fxaa-tonemap-pass.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { FXAATonemapPass } from './fxaa-tonemap-pass';

describe('FXAATonemapPass', () => {
  it('should be optional (dead-pass culled when unused)', () => {
    const pass = new FXAATonemapPass();
    expect(pass.optional).toBe(true);
  });

  it('should read scene-hdr and write swapchain', () => {
    const pass = new FXAATonemapPass();
    expect(pass.reads).toContain('scene-hdr');
    expect(pass.writes).toContain('swapchain');
  });

  it('should accept tonemap mode', () => {
    const pass = new FXAATonemapPass();
    pass.setTonemapMode(1);
    // No error
  });
});
```

Run: `cd ts && npx vitest run src/render/passes/fxaa-tonemap-pass.test.ts`
Expected: PASS

**Commit:**
```bash
git add ts/src/render/passes/fxaa-tonemap-pass.test.ts
git commit -m "test(phase5.5): add FXAATonemapPass unit tests"
```

---

## Part 7: Gradient Rendering

### Task 26: Create gradient WGSL shader

**Files:**
- Create: `ts/src/shaders/gradient.wgsl`

PrimParams layout for Gradient:
- `[0]=type` (0=linear, 1=radial, 2=conic)
- `[1]=angle` (degrees, for linear/conic)
- `[2..5]=stop0_pos, stop0_r, stop0_g, stop0_b`
- `[6..7]=stop1_pos, stop1_r` (remaining stop1 colors use texLayerIndices to encode, or use a 2-stop simplification)

For Phase 5.5, implement 2-stop gradients (linear + radial). Full gradient support with arbitrary stops via LUT texture is a future enhancement.

The shader uses the same bind group layout as basic.wgsl. The vertex shader positions the quad via the entity transform. The fragment shader computes gradient color based on UV coordinates and params.

```wgsl
// Gradient shader — 2-stop linear and radial gradients.
// PrimParams: [type, angle, stop0_pos, stop0_r, stop0_g, stop0_b, stop1_pos, stop1_r]
// stop1 g,b are packed into renderMeta[entity*2] (mesh_handle field, repurposed for gradients)

// ... (same bindings as basic.wgsl) ...

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4f {
    let base = in.entityIdx * 8u;
    let gradType = u32(primParams[base + 0u]);
    let angle = primParams[base + 1u];
    let stop0Pos = primParams[base + 2u];
    let stop0 = vec3f(primParams[base + 3u], primParams[base + 4u], primParams[base + 5u]);
    let stop1Pos = primParams[base + 6u];
    let stop1R = primParams[base + 7u];
    // Use texture layer for stop1 GB (packed as u16+u16)
    let packed = texLayerIndices[in.entityIdx];
    let stop1G = f32((packed >> 8u) & 0xFFu) / 255.0;
    let stop1B = f32(packed & 0xFFu) / 255.0;
    let stop1 = vec3f(stop1R, stop1G, stop1B);

    var t: f32;
    if (gradType == 0u) {
        // Linear gradient along angle
        let rad = angle * 3.14159265 / 180.0;
        let dir = vec2f(cos(rad), sin(rad));
        t = dot(in.uv - 0.5, dir) + 0.5;
    } else if (gradType == 1u) {
        // Radial gradient from center
        t = length(in.uv - 0.5) * 2.0;
    } else {
        // Conic gradient
        let rad = angle * 3.14159265 / 180.0;
        let centered = in.uv - 0.5;
        t = (atan2(centered.y, centered.x) + 3.14159265 - rad) / (2.0 * 3.14159265);
        t = fract(t);
    }

    // Map t through stops
    let s = clamp((t - stop0Pos) / max(stop1Pos - stop0Pos, 0.001), 0.0, 1.0);
    let color = mix(stop0, stop1, s);

    return vec4f(color, 1.0);
}
```

**Commit:**
```bash
git add ts/src/shaders/gradient.wgsl
git commit -m "feat(phase5.5): add gradient WGSL shader (linear, radial, conic)"
```

---

### Task 27: Register gradient pipeline + tests

**Files:**
- Modify: `ts/src/renderer.ts`

```typescript
import gradientShaderCode from './shaders/gradient.wgsl?raw';

ForwardPass.SHADER_SOURCES = {
  0: shaderCode,
  1: lineShaderCode,
  4: gradientShaderCode,  // Gradient = 4
};
```

Add a test in `entity-handle.test.ts` confirming the gradient fluent API works (already done in Task 8).

**Commit:**
```bash
git commit -m "feat(phase5.5): register gradient pipeline (type 4)"
```

---

## Part 8: Box Shadow Rendering

### Task 28: Create box shadow WGSL shader

**Files:**
- Create: `ts/src/shaders/box-shadow.wgsl`

Implements Evan Wallace's SDF box shadow technique with `erf()` approximation.

PrimParams layout for BoxShadow:
- `[0]=rectW, [1]=rectH, [2]=cornerRadius, [3]=blur`
- `[4]=colorR, [5]=colorG, [6]=colorB, [7]=colorA`

```wgsl
// SDF Box Shadow shader — Evan Wallace technique.
// Closed-form convolution of Gaussian 1D with box using erf().
// Blur radius 2 or 200 — same cost.

// ... (same bindings as basic.wgsl) ...

// Abramowitz-Stegun erf() approximation (max error ~1.5×10⁻⁷)
fn erf_approx(x: f32) -> f32 {
    let a1 =  0.254829592;
    let a2 = -0.284496736;
    let a3 =  1.421413741;
    let a4 = -1.453152027;
    let a5 =  1.061405429;
    let p  =  0.3275911;
    let s = sign(x);
    let ax = abs(x);
    let t = 1.0 / (1.0 + p * ax);
    let y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-ax * ax);
    return s * y;
}

// 1D shadow integral: integral of Gaussian convolved with box from a to b
fn shadowIntegral(x: f32, sigma: f32) -> f32 {
    let s = x / (sigma * 1.4142135); // sqrt(2)
    return erf_approx(s);
}

// 2D rounded box SDF shadow
fn boxShadow2D(uv: vec2f, rectSize: vec2f, cornerRadius: f32, blur: f32) -> f32 {
    let sigma = blur * 0.5;
    if (sigma < 0.001) {
        // Sharp shadow: use SDF directly
        let q = abs(uv) - rectSize * 0.5 + cornerRadius;
        let d = length(max(q, vec2f(0.0))) + min(max(q.x, q.y), 0.0) - cornerRadius;
        return select(0.0, 1.0, d < 0.0);
    }

    // Separable Gaussian × Box convolution using erf
    let half = rectSize * 0.5 - cornerRadius;
    let ax = shadowIntegral(uv.x + half.x, sigma) - shadowIntegral(uv.x - half.x, sigma);
    let ay = shadowIntegral(uv.y + half.y, sigma) - shadowIntegral(uv.y - half.y, sigma);
    return ax * ay * 0.25;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4f {
    let base = in.entityIdx * 8u;
    let rectW = primParams[base + 0u];
    let rectH = primParams[base + 1u];
    let cornerRadius = primParams[base + 2u];
    let blur = primParams[base + 3u];
    let colorR = primParams[base + 4u];
    let colorG = primParams[base + 5u];
    let colorB = primParams[base + 6u];
    let colorA = primParams[base + 7u];

    // UV is [0,1] from unit quad; map to rect-relative coords
    let localPos = (in.uv - 0.5) * vec2f(rectW + blur * 4.0, rectH + blur * 4.0);
    let alpha = boxShadow2D(localPos, vec2f(rectW, rectH), cornerRadius, blur);

    return vec4f(colorR, colorG, colorB, colorA * alpha);
}
```

**Commit:**
```bash
git add ts/src/shaders/box-shadow.wgsl
git commit -m "feat(phase5.5): add SDF box shadow shader (Evan Wallace erf technique)"
```

---

### Task 29: Register box shadow pipeline + tests

**Files:**
- Modify: `ts/src/renderer.ts`

```typescript
import boxShadowShaderCode from './shaders/box-shadow.wgsl?raw';

ForwardPass.SHADER_SOURCES = {
  0: shaderCode,
  1: lineShaderCode,
  4: gradientShaderCode,
  5: boxShadowShaderCode,  // BoxShadow = 5
};
```

**Commit:**
```bash
git commit -m "feat(phase5.5): register box shadow pipeline (type 5)"
```

---

## Part 9: MSDF Text Rendering

### Task 30: Create FontAtlas types and loader

**Files:**
- Create: `ts/src/text/font-atlas.ts`

```typescript
/** Glyph metrics from MSDF atlas JSON metadata (msdf-atlas-gen format). */
export interface GlyphMetrics {
  unicode: number;
  advance: number;
  planeBounds?: { left: number; bottom: number; right: number; top: number };
  atlasBounds?: { left: number; bottom: number; right: number; top: number };
}

/** Font atlas metadata parsed from msdf-atlas-gen JSON output. */
export interface FontAtlas {
  atlas: {
    type: 'msdf' | 'mtsdf';
    distanceRange: number;   // pixels of SDF range
    size: number;            // font size in atlas
    width: number;           // atlas texture width
    height: number;          // atlas texture height
  };
  metrics: {
    lineHeight: number;
    ascender: number;
    descender: number;
  };
  glyphs: GlyphMetrics[];
  /** Indexed by unicode code point for O(1) lookup. */
  glyphMap: Map<number, GlyphMetrics>;
}

/** Parse msdf-atlas-gen JSON metadata into a FontAtlas. */
export function parseFontAtlas(json: unknown): FontAtlas {
  const data = json as any;
  const glyphs: GlyphMetrics[] = data.glyphs ?? [];
  const glyphMap = new Map<number, GlyphMetrics>();
  for (const g of glyphs) {
    glyphMap.set(g.unicode, g);
  }
  return {
    atlas: data.atlas,
    metrics: data.metrics,
    glyphs,
    glyphMap,
  };
}

/** Load a font atlas from URL (JSON metadata + PNG texture). */
export async function loadFontAtlas(
  jsonUrl: string,
  textureUrl: string,
): Promise<{ atlas: FontAtlas; bitmap: ImageBitmap }> {
  const [jsonResp, bitmapResp] = await Promise.all([
    fetch(jsonUrl).then(r => r.json()),
    fetch(textureUrl).then(r => r.blob()).then(b => createImageBitmap(b)),
  ]);
  return { atlas: parseFontAtlas(jsonResp), bitmap: bitmapResp };
}
```

**Commit:**
```bash
git add ts/src/text/font-atlas.ts
git commit -m "feat(phase5.5): add FontAtlas types and loader for MSDF text"
```

---

### Task 31: Create basic text layout engine

**Files:**
- Create: `ts/src/text/text-layout.ts`

```typescript
import type { FontAtlas, GlyphMetrics } from './font-atlas';

/** Positioned glyph for rendering. */
export interface LayoutGlyph {
  unicode: number;
  metrics: GlyphMetrics;
  /** Screen-space position of glyph quad (bottom-left). */
  x: number;
  y: number;
  /** Glyph quad size in screen pixels. */
  width: number;
  height: number;
}

/** Layout a string into positioned glyphs using atlas metrics. */
export function layoutText(
  text: string,
  atlas: FontAtlas,
  fontSize: number,
  startX: number,
  startY: number,
): LayoutGlyph[] {
  const scale = fontSize / atlas.atlas.size;
  const result: LayoutGlyph[] = [];
  let cursorX = startX;

  for (let i = 0; i < text.length; i++) {
    const code = text.charCodeAt(i);
    const glyph = atlas.glyphMap.get(code);
    if (!glyph) continue;

    if (glyph.planeBounds && glyph.atlasBounds) {
      const pb = glyph.planeBounds;
      const width = (pb.right - pb.left) * fontSize;
      const height = (pb.top - pb.bottom) * fontSize;
      const xOff = pb.left * fontSize;
      const yOff = pb.bottom * fontSize;

      result.push({
        unicode: code,
        metrics: glyph,
        x: cursorX + xOff,
        y: startY + yOff,
        width,
        height,
      });
    }

    cursorX += glyph.advance * scale * atlas.atlas.size;
  }

  return result;
}
```

**Commit:**
```bash
git add ts/src/text/text-layout.ts
git commit -m "feat(phase5.5): add basic text layout engine for MSDF rendering"
```

---

### Task 32: Create MSDF WGSL shader

**Files:**
- Create: `ts/src/shaders/msdf-text.wgsl`

PrimParams layout for SDFGlyph:
- `[0]=atlasU0, [1]=atlasV0, [2]=atlasU1, [3]=atlasV1` — atlas UV rect
- `[4]=screenPxRange` — SDF range in screen pixels (for AA)
- `[5]=colorR, [6]=colorG, [7]=colorB` — text color

```wgsl
// MSDF text rendering shader.
// Each glyph is an instanced quad positioned by the entity transform.
// Fragment shader: median(r,g,b) SDF with screen-pixel-range AA.

// ... (same bindings as basic.wgsl) ...

fn median3(r: f32, g: f32, b: f32) -> f32 {
    return max(min(r, g), min(max(r, g), b));
}

@vertex
fn vs_main(
    @location(0) position: vec3f,
    @builtin(instance_index) instanceIdx: u32,
) -> VertexOutput {
    let entityIdx = visibleIndices[instanceIdx];
    let model = transforms[entityIdx];

    // Read atlas UV rect from primParams
    let base = entityIdx * 8u;
    let atlasU0 = primParams[base + 0u];
    let atlasV0 = primParams[base + 1u];
    let atlasU1 = primParams[base + 2u];
    let atlasV1 = primParams[base + 3u];

    var out: VertexOutput;
    out.clipPosition = camera.viewProjection * model * vec4f(position, 1.0);
    // Map unit quad UVs [0,1] to atlas UV rect
    let localUV = position.xy + 0.5;
    out.uv = vec2f(
        mix(atlasU0, atlasU1, localUV.x),
        mix(atlasV0, atlasV1, localUV.y),
    );
    out.entityIdx = entityIdx;
    out.texTier = 0u;  // MSDF atlas is always tier 0 for now
    out.texLayer = 0u;

    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4f {
    let base = in.entityIdx * 8u;
    let screenPxRange = primParams[base + 4u];
    let colorR = primParams[base + 5u];
    let colorG = primParams[base + 6u];
    let colorB = primParams[base + 7u];

    // Sample MSDF atlas (tier 0, layer from texLayerIndices)
    let packed = texLayerIndices[in.entityIdx];
    let layer = packed & 0xFFFFu;
    let msdf = textureSample(tier0Tex, texSampler, in.uv, layer);

    // Median of three channels
    let sd = median3(msdf.r, msdf.g, msdf.b);

    // Compute screen-space derivative for anti-aliasing
    let screenTexSize = vec2f(
        length(vec2f(dpdx(in.uv.x), dpdy(in.uv.x))),
        length(vec2f(dpdx(in.uv.y), dpdy(in.uv.y)))
    );
    let avgScreenTexSize = 0.5 * (screenTexSize.x + screenTexSize.y);
    let screenPxDistance = screenPxRange * (sd - 0.5);
    let opacity = clamp(screenPxDistance / avgScreenTexSize + 0.5, 0.0, 1.0);

    if (opacity < 0.01) {
        discard;
    }

    return vec4f(colorR, colorG, colorB, opacity);
}
```

**Commit:**
```bash
git add ts/src/shaders/msdf-text.wgsl
git commit -m "feat(phase5.5): add MSDF text rendering shader with median + screen-px-range AA"
```

---

### Task 33: Register MSDF pipeline + TextManager integration

**Files:**
- Modify: `ts/src/renderer.ts`
- Create: `ts/src/text/text-manager.ts`

In `renderer.ts`:
```typescript
import msdfShaderCode from './shaders/msdf-text.wgsl?raw';

ForwardPass.SHADER_SOURCES = {
  0: shaderCode,
  1: lineShaderCode,
  2: msdfShaderCode,     // SDFGlyph = 2
  4: gradientShaderCode,
  5: boxShadowShaderCode,
};
```

Create `ts/src/text/text-manager.ts`:
```typescript
import type { FontAtlas } from './font-atlas';
import { loadFontAtlas } from './font-atlas';
import type { TextureManager } from '../texture-manager';

/**
 * Manages loaded font atlases and their texture layers.
 * Each font atlas gets one layer in tier 0 (64px) of the TextureManager.
 */
export class TextManager {
  private atlases = new Map<string, { atlas: FontAtlas; textureLayer: number }>();

  constructor(private readonly textureManager: TextureManager) {}

  async loadFont(name: string, jsonUrl: string, textureUrl: string): Promise<FontAtlas> {
    const { atlas, bitmap } = await loadFontAtlas(jsonUrl, textureUrl);
    // Upload atlas bitmap to texture manager — the atlas image goes into a texture layer
    // For now, use tier 0 (64px). In production, atlas size determines tier.
    const textureLayer = 0; // Placeholder — integrate with TextureManager.loadFromBitmap()
    this.atlases.set(name, { atlas, textureLayer });
    return atlas;
  }

  getAtlas(name: string): { atlas: FontAtlas; textureLayer: number } | undefined {
    return this.atlases.get(name);
  }
}
```

**Commit:**
```bash
git add ts/src/text/text-manager.ts ts/src/renderer.ts
git commit -m "feat(phase5.5): register MSDF pipeline + TextManager subsystem"
```

---

### Task 34: Write text layout tests

**Files:**
- Create: `ts/src/text/text-layout.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { layoutText, type LayoutGlyph } from './text-layout';
import type { FontAtlas } from './font-atlas';

const mockAtlas: FontAtlas = {
  atlas: { type: 'msdf', distanceRange: 4, size: 32, width: 512, height: 512 },
  metrics: { lineHeight: 1.2, ascender: 0.8, descender: -0.2 },
  glyphs: [
    { unicode: 72, advance: 0.6, planeBounds: { left: 0, bottom: 0, right: 0.5, top: 0.8 }, atlasBounds: { left: 0, bottom: 0, right: 16, top: 26 } },
    { unicode: 105, advance: 0.3, planeBounds: { left: 0.05, bottom: 0, right: 0.25, top: 0.8 }, atlasBounds: { left: 20, bottom: 0, right: 26, top: 26 } },
  ],
  glyphMap: new Map(),
};
mockAtlas.glyphMap.set(72, mockAtlas.glyphs[0]);  // 'H'
mockAtlas.glyphMap.set(105, mockAtlas.glyphs[1]); // 'i'

describe('layoutText', () => {
  it('should position glyphs sequentially', () => {
    const glyphs = layoutText('Hi', mockAtlas, 32, 100, 200);
    expect(glyphs).toHaveLength(2);
    expect(glyphs[0].unicode).toBe(72); // H
    expect(glyphs[0].x).toBe(100);      // starts at startX
    expect(glyphs[1].x).toBeGreaterThan(glyphs[0].x); // i is after H
  });

  it('should skip missing glyphs', () => {
    const glyphs = layoutText('H?i', mockAtlas, 32, 0, 0);
    expect(glyphs).toHaveLength(2); // ? is missing from atlas
  });

  it('should scale with fontSize', () => {
    const small = layoutText('H', mockAtlas, 16, 0, 0);
    const large = layoutText('H', mockAtlas, 64, 0, 0);
    expect(large[0].width).toBeGreaterThan(small[0].width);
  });
});
```

Run: `cd ts && npx vitest run src/text/text-layout.test.ts`
Expected: PASS

**Commit:**
```bash
git add ts/src/text/text-layout.test.ts
git commit -m "test(phase5.5): add text layout unit tests"
```

---

## Part 10: JFA Selection Outlines

### Task 35: Create SelectionSeedPass + shader

**Files:**
- Create: `ts/src/shaders/selection-seed.wgsl`
- Create: `ts/src/render/passes/selection-seed-pass.ts`

The seed pass renders selected entities to an off-screen texture with their entity ID encoded as UV coordinates. Non-selected entities are not drawn.

**Shader** (`selection-seed.wgsl`):
```wgsl
// Selection seed pass: renders selected entity pixels as seeds for JFA.
// Output: R = normalized X position, G = normalized Y position (seed coords).
// Non-selected pixels: (0, 0, 0, 0).

// Uses the same bindings as forward pass but writes to a selection-seed texture.

// ... (same vertex shader as basic.wgsl) ...

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4f {
    // Output seed position as normalized coordinates
    let pos = in.clipPosition.xy;
    return vec4f(pos.x, pos.y, 1.0, 1.0);
}
```

**Pass implementation** — similar to ForwardPass but renders to `selection-seed` texture and only draws selected entities (filtered by a selection buffer or a separate CullPass variant).

For Phase 5.5 simplification: the SelectionSeedPass renders ALL entities of a special "selected" render primitive or uses a selection bitmask buffer. The simplest approach: a separate GPU buffer `selection-mask` (1 u32 per entity, 0 or 1) that the seed shader checks.

```typescript
export class SelectionSeedPass implements RenderPass {
  readonly name = 'selection-seed';
  readonly reads = ['visible-indices', 'entity-transforms', 'indirect-args', 'selection-mask'];
  readonly writes = ['selection-seed'];
  readonly optional = true;
  // ... setup creates off-screen RGBA8 texture, pipeline, bind groups
}
```

**Commit:**
```bash
git add ts/src/shaders/selection-seed.wgsl ts/src/render/passes/selection-seed-pass.ts
git commit -m "feat(phase5.5): add SelectionSeedPass for JFA outline input"
```

---

### Task 36: Create JFAPass + shader

**Files:**
- Create: `ts/src/shaders/jfa.wgsl`
- Create: `ts/src/render/passes/jfa-pass.ts`

**JFA Algorithm:**
1. Start with step size = max(width, height) / 2
2. For each pixel, sample 9 neighbors at ±step distance
3. Keep the nearest seed position
4. Halve step size, repeat for log₂(maxDim) iterations

**Shader** (`jfa.wgsl`):
```wgsl
// Jump Flood Algorithm — one iteration per dispatch.
// Reads from input texture, writes to output texture.
// Ping-pong between two textures across iterations.

@group(0) @binding(0) var inputTex: texture_2d<f32>;
@group(0) @binding(1) var inputSampler: sampler;
@group(0) @binding(2) var<uniform> params: JFAParams;

struct JFAParams {
    stepSize: f32,
    texelSize: vec2f,
    _pad: f32,
};

struct VertexOutput {
    @builtin(position) position: vec4f,
    @location(0) uv: vec2f,
};

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
    var out: VertexOutput;
    let x = f32(i32(vertexIndex & 1u) * 4 - 1);
    let y = f32(i32(vertexIndex >> 1u) * 4 - 1);
    out.position = vec4f(x, y, 0.0, 1.0);
    out.uv = vec2f((x + 1.0) * 0.5, (1.0 - y) * 0.5);
    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4f {
    let step = params.stepSize * params.texelSize;
    var bestSeed = textureSample(inputTex, inputSampler, in.uv);
    var bestDist = 1e10;

    if (bestSeed.b > 0.5) {
        bestDist = length(in.uv - bestSeed.rg);
    }

    // Sample 9 neighbors (3×3 at step distance)
    for (var dy = -1; dy <= 1; dy++) {
        for (var dx = -1; dx <= 1; dx++) {
            if (dx == 0 && dy == 0) { continue; }
            let offset = vec2f(f32(dx), f32(dy)) * step;
            let sample = textureSample(inputTex, inputSampler, in.uv + offset);
            if (sample.b > 0.5) {
                let dist = length(in.uv - sample.rg);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestSeed = sample;
                }
            }
        }
    }

    return bestSeed;
}
```

**Pass implementation:**
```typescript
export class JFAPass implements RenderPass {
  readonly name: string;
  readonly reads: string[];
  readonly writes: string[];
  readonly optional = true;
  // Constructor takes iteration index to determine read/write texture names
  // Ping-pong: even iterations read jfa-a write jfa-b, odd read jfa-b write jfa-a
}
```

**Note:** The RenderGraph needs multiple JFA pass instances (one per iteration, ~10 iterations for 1080p). Each is a separate pass node in the DAG with alternating read/write resources.

**Commit:**
```bash
git add ts/src/shaders/jfa.wgsl ts/src/render/passes/jfa-pass.ts
git commit -m "feat(phase5.5): add JFA pass with ping-pong texture iteration"
```

---

### Task 37: Create OutlineCompositePass + shader

**Files:**
- Create: `ts/src/shaders/outline-composite.wgsl`
- Create: `ts/src/render/passes/outline-composite-pass.ts`

Reads the final JFA texture and the scene texture. Computes distance to nearest seed at each pixel. If distance is within outline width, blends outline color.

```wgsl
// Outline composite: reads JFA result + scene, draws outline where
// distance to nearest selected entity is within outline width.

@group(0) @binding(0) var sceneTex: texture_2d<f32>;
@group(0) @binding(1) var jfaTex: texture_2d<f32>;
@group(0) @binding(2) var inputSampler: sampler;
@group(0) @binding(3) var<uniform> params: OutlineParams;

struct OutlineParams {
    outlineColor: vec4f,
    outlineWidth: f32,
    texelSize: vec2f,
    _pad: f32,
};

// ... full-screen triangle vertex shader (same as FXAA) ...

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4f {
    let scene = textureSample(sceneTex, inputSampler, in.uv);
    let jfa = textureSample(jfaTex, inputSampler, in.uv);

    if (jfa.b < 0.5) {
        return scene; // No seed nearby
    }

    let dist = length(in.uv - jfa.rg) / length(params.texelSize);
    let outlineAlpha = smoothstep(params.outlineWidth + 1.0, params.outlineWidth - 1.0, dist);

    // Don't draw outline on top of the selected entity itself
    let selfSeed = textureSample(jfaTex, inputSampler, in.uv);
    let selfDist = length(in.uv - selfSeed.rg) / length(params.texelSize);
    if (selfDist < 1.0) {
        return scene;
    }

    return mix(scene, params.outlineColor, outlineAlpha * params.outlineColor.a);
}
```

```typescript
export class OutlineCompositePass implements RenderPass {
  readonly name = 'outline-composite';
  readonly reads = ['scene-hdr', 'jfa-result'];
  readonly writes = ['swapchain'];
  readonly optional = true;
  // ...
}
```

**Commit:**
```bash
git add ts/src/shaders/outline-composite.wgsl ts/src/render/passes/outline-composite-pass.ts
git commit -m "feat(phase5.5): add OutlineCompositePass with SDF distance outline"
```

---

### Task 38: Create selection state manager

**Files:**
- Create: `ts/src/selection.ts`

```typescript
/**
 * Manages the set of selected entity IDs.
 * Updates a GPU buffer (selection-mask) for the SelectionSeedPass.
 */
export class SelectionManager {
  private selected = new Set<number>();
  private maskBuffer: GPUBuffer | null = null;
  private dirty = false;

  constructor(private readonly maxEntities: number) {}

  select(entityId: number): void {
    this.selected.add(entityId);
    this.dirty = true;
  }

  deselect(entityId: number): void {
    this.selected.delete(entityId);
    this.dirty = true;
  }

  clear(): void {
    this.selected.clear();
    this.dirty = true;
  }

  isSelected(entityId: number): boolean {
    return this.selected.has(entityId);
  }

  get count(): number {
    return this.selected.size;
  }

  /** Upload selection mask to GPU if dirty. */
  uploadMask(device: GPUDevice, buffer: GPUBuffer): void {
    if (!this.dirty) return;
    const mask = new Uint32Array(this.maxEntities);
    for (const id of this.selected) {
      if (id < this.maxEntities) mask[id] = 1;
    }
    device.queue.writeBuffer(buffer, 0, mask, 0, this.maxEntities);
    this.dirty = false;
  }

  destroy(): void {
    this.selected.clear();
  }
}
```

**Commit:**
```bash
git add ts/src/selection.ts
git commit -m "feat(phase5.5): add SelectionManager with GPU mask upload"
```

---

### Task 39: Wire JFA pipeline into RenderGraph + Selection API on Hyperion

**Files:**
- Modify: `ts/src/renderer.ts`
- Modify: `ts/src/hyperion.ts`

In `renderer.ts`: When outline mode is enabled, add JFA passes to the graph:
```typescript
// Create selection-mask buffer, selection-seed texture, jfa-a/jfa-b textures
// Add: SelectionSeedPass → JFAPass×10 → OutlineCompositePass
// All optional: true — dead-pass culled when no selection
```

In `hyperion.ts`:
```typescript
/** Configure selection outlines. */
get selection(): SelectionManager { ... }

enableOutlines(options: { color: [number, number, number, number]; width: number }): void { ... }
```

**Commit:**
```bash
git commit -m "feat(phase5.5): wire JFA outline pipeline + selection API on Hyperion"
```

---

### Task 40: Write JFA + selection tests

**Files:**
- Create: `ts/src/selection.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { SelectionManager } from './selection';

describe('SelectionManager', () => {
  it('should track selected entities', () => {
    const sm = new SelectionManager(100);
    sm.select(5);
    sm.select(10);
    expect(sm.isSelected(5)).toBe(true);
    expect(sm.isSelected(10)).toBe(true);
    expect(sm.isSelected(3)).toBe(false);
    expect(sm.count).toBe(2);
  });

  it('should deselect entities', () => {
    const sm = new SelectionManager(100);
    sm.select(5);
    sm.deselect(5);
    expect(sm.isSelected(5)).toBe(false);
    expect(sm.count).toBe(0);
  });

  it('should clear all selections', () => {
    const sm = new SelectionManager(100);
    sm.select(1);
    sm.select(2);
    sm.select(3);
    sm.clear();
    expect(sm.count).toBe(0);
  });
});
```

Run: `cd ts && npx vitest run src/selection.test.ts`
Expected: PASS

**Commit:**
```bash
git add ts/src/selection.test.ts
git commit -m "test(phase5.5): add SelectionManager unit tests"
```

---

## Part 11: Integration + Documentation

### Task 41: Update barrel export

**Files:**
- Modify: `ts/src/index.ts`

Add new exports:
```typescript
export { RenderPrimitiveType } from './entity-handle';
export { SelectionManager } from './selection';
export type { FontAtlas, GlyphMetrics } from './text/font-atlas';
export { loadFontAtlas } from './text/font-atlas';
export { layoutText } from './text/text-layout';
```

**Commit:**
```bash
git add ts/src/index.ts
git commit -m "feat(phase5.5): update barrel export with new Phase 5.5 types"
```

---

### Task 42: Full validation run

**Step 1: Rust validation**

Run: `cargo test -p hyperion-core && cargo clippy -p hyperion-core`
Expected: All tests PASS, no warnings

**Step 2: WASM build**

Run: `cd ts && npm run build:wasm`
Expected: SUCCESS

**Step 3: TypeScript validation**

Run: `cd ts && npm test && npx tsc --noEmit`
Expected: All tests PASS, no type errors

**Step 4: Visual smoke test**

Run: `cd ts && npm run dev`
- Open browser, verify quads still render
- Add test entities with `.line()`, `.boxShadow()` — verify rendering
- Toggle FXAA — verify post-processing

---

### Task 43: Update CLAUDE.md

**Files:**
- Modify: `CLAUDE.md`

Add new test commands, update module table with new files, update Implementation Status, add new gotchas:

- New test files: `selection.test.ts`, `text-layout.test.ts`, `fxaa-tonemap-pass.test.ts`
- New modules: `text/font-atlas.ts`, `text/text-layout.ts`, `text/text-manager.ts`, `selection.ts`
- New passes: `fxaa-tonemap-pass.ts`, `selection-seed-pass.ts`, `jfa-pass.ts`, `outline-composite-pass.ts`
- New shaders: `line.wgsl`, `gradient.wgsl`, `box-shadow.wgsl`, `msdf-text.wgsl`, `fxaa-tonemap.wgsl`, `selection-seed.wgsl`, `jfa.wgsl`, `outline-composite.wgsl`
- Update test count
- Update Implementation Status to Phase 5.5 complete
- Add gotchas for multi-pipeline ForwardPass, JFA iteration count, MSDF atlas requirements

**Commit:**
```bash
git commit -m "docs: update CLAUDE.md for Phase 5.5"
```

---

### Task 44: Update PROJECT_ARCHITECTURE.md

**Files:**
- Modify: `PROJECT_ARCHITECTURE.md`

Add sections on:
- Multi-primitive rendering pipeline
- Per-type pipeline dispatch in ForwardPass
- FXAA + tonemapping post-processing
- JFA selection outlines
- MSDF text rendering subsystem
- PrimitiveParams SoA buffer

**Commit:**
```bash
git commit -m "docs: update PROJECT_ARCHITECTURE.md for Phase 5.5"
```

---

### Task 45: Final commit + merge readiness

**Step 1: Final full validation**

Run: `cargo test -p hyperion-core && cargo clippy -p hyperion-core && cd ts && npm test && npx tsc --noEmit`
Expected: ALL PASS

**Step 2: Review git log**

Run: `git log --oneline -20`
Verify clean commit history with descriptive messages.

**Step 3: Ready for merge**

The Phase 5.5 branch is ready for review and merge to master.

---

## Summary

| Part | Tasks | New Files | Key Deliverables |
|------|-------|-----------|-----------------|
| 1: PrimitiveParams (Rust) | 1-5 | 0 | PrimitiveParams component, ring buffer commands, WASM exports |
| 2: PrimitiveParams (TS) | 6-10 | 0 | Ring buffer sync, EntityHandle fluent API, GPU buffer wiring |
| 3: Multi-Type CullPass | 11-13 | 0 | Per-type grouping in cull shader, multi-region visible-indices |
| 4: Multi-Pipeline ForwardPass | 14-17 | 0 | Pipeline registry, per-type draw dispatch |
| 5: Line Rendering | 18-20 | 1 | line.wgsl, screen-space expansion, SDF dash |
| 6: FXAA + Tonemapping | 21-25 | 2 | fxaa-tonemap.wgsl, FXAATonemapPass, scene-hdr intermediate |
| 7: Gradient Rendering | 26-27 | 1 | gradient.wgsl (linear, radial, conic) |
| 8: Box Shadow Rendering | 28-29 | 1 | box-shadow.wgsl (Evan Wallace erf technique) |
| 9: MSDF Text | 30-34 | 4 | FontAtlas, text layout, msdf-text.wgsl, TextManager |
| 10: JFA Selection Outlines | 35-40 | 5 | 3 shaders, 3 passes, SelectionManager |
| 11: Documentation | 41-45 | 0 | CLAUDE.md, PROJECT_ARCHITECTURE.md, barrel export |

**Total: 45 tasks, ~14 new files, ~2500 lines of new code**
