# Phase 7.5 — Stability & Bugfix Micro-Phase

> **Date**: 21 February 2026 | **Scope**: 3 targeted fixes from external architecture review | **Risk**: Low — no new features, only correctness and forward-compatibility improvements

---

## Motivation

An external architecture review of `PROJECT_ARCHITECTURE.md` and Phase 4.5 plan identified three real defects:

1. **Silent 32-child overflow** — entities exceeding 32 children silently drop additional children with no diagnostic output
2. **Immediate mode bounds desync** — `patchTransforms()` patches rendering position but not the bounds buffer used by `hitTestRay()`, causing picks to miss during fast drags
3. **Audio listener coupled to RAF** — spatial audio listener position freezes during main-thread jank because it reads synchronously from `CameraAPI` in the RAF-driven `tick()`

Two additional observations were acknowledged but deferred:
- WGSL texture tier switch (requires bindless resources, not yet in WebGPU spec)
- Documentation split (deferred until external contributors exist)

---

## Fix 1: OverflowChildren Heap Fallback

### Problem

`Children` uses a fixed `[u32; 32]` inline array for cache performance. When `add()` returns `false` at capacity, the caller in `command_processor.rs` discards the return value. The 33rd child vanishes with zero diagnostic output — no warning, no error.

### Design

Add a new ECS component `OverflowChildren` that acts as a heap-allocated fallback for entities exceeding 32 children.

**Rust components** (`components.rs`):
```rust
/// Heap fallback for entities with more than 32 children.
/// Only attached when Children::add() overflows.
pub struct OverflowChildren {
    pub items: Vec<u32>,
}
```

Note: `OverflowChildren` is NOT `#[repr(C)]`/Pod — it contains a `Vec` (heap-allocated). It is never uploaded to the GPU. It is only used for scene graph traversal.

**Rust command processor** (`command_processor.rs`):

In the `SetParent` handler, when `children.add(child_id)` returns `false`:
```rust
if !children.add(cmd.entity_id) {
    // Overflow — get or create OverflowChildren
    if let Ok(mut overflow) = world.get::<&mut OverflowChildren>(parent_entity) {
        overflow.items.push(cmd.entity_id);
    } else {
        world.insert_one(parent_entity, OverflowChildren { items: vec![cmd.entity_id] }).ok();
    }
}
```

hecs API validation (via Context7): `world.insert_one(entity, component)` dynamically adds a component to an existing entity. `Option<&OverflowChildren>` is natively supported in hecs queries.

**Rust removal logic** (`command_processor.rs`):

When removing a child from a parent (unparent or reparent), check `Children` first, then `OverflowChildren`:
```rust
// Try removing from Children first
let removed = children.remove(child_id);
if !removed {
    // Try OverflowChildren
    if let Ok(mut overflow) = world.get::<&mut OverflowChildren>(parent_entity) {
        overflow.items.retain(|&id| id != child_id);
        // If overflow is now empty, remove the component
        if overflow.items.is_empty() {
            drop(overflow);
            world.remove_one::<OverflowChildren>(parent_entity).ok();
        }
    }
}
```

**Rust systems** (`systems.rs`):

`propagate_transforms` must iterate both `Children` and `OverflowChildren`:
```rust
// Query with optional OverflowChildren
for (entity, (children, overflow, matrix)) in
    world.query_mut::<(&Children, Option<&OverflowChildren>, &ModelMatrix)>()
{
    // Propagate to inline children
    for i in 0..children.count as usize {
        propagate_to_child(children.slots[i], &matrix.0, ...);
    }
    // Propagate to overflow children (if any)
    if let Some(overflow) = overflow {
        for &child_id in &overflow.items {
            propagate_to_child(child_id, &matrix.0, ...);
        }
    }
}
```

**TypeScript side**: No changes. The overflow is entirely within the Rust ECS. The ring buffer protocol is unchanged.

### Testing

- Spawn entity with 33+ children, verify all have correct parent references
- Verify `propagate_transforms` applies to all children (inline + overflow)
- Verify removal from overflow children works correctly
- Verify `OverflowChildren` component is removed when it becomes empty
- Verify `Children::remove()` returns a boolean indicating whether the child was found

### Impact

- **Rust only**: `components.rs`, `command_processor.rs`, `systems.rs`
- **No TS changes, no ring buffer changes, no WASM export changes**
- `Children::remove()` must return `bool` (currently returns nothing — needs a small signature change)

---

## Fix 2: Immediate Mode Bounds Patching

### Problem

`ImmediateState.patchTransforms()` patches the transforms buffer (column 3 = translation xyz) for zero-latency rendering. But `hitTestRay()` reads from the **bounds** buffer (`[x, y, z, radius]` per entity), which is NOT patched. During fast drag-and-drop, the entity renders under the cursor but picks test against the stale WASM-reported position (1-2 frames behind).

A test at `immediate-state.test.ts:123` explicitly documents this as a "known limitation."

### Design

Add `patchBounds()` to `ImmediateState`:

```typescript
patchBounds(
    bounds: Float32Array,
    entityIds: Uint32Array,
    entityCount: number,
): void {
    if (this.overrides.size === 0) return;
    for (let i = 0; i < entityCount; i++) {
        const pos = this.overrides.get(entityIds[i]);
        if (pos) {
            const base = i * 4; // bounds layout: [x, y, z, radius]
            bounds[base]     = pos[0]; // x
            bounds[base + 1] = pos[1]; // y
            bounds[base + 2] = pos[2]; // z
            // bounds[base + 3] = radius — intentionally NOT patched
        }
    }
}
```

In `Hyperion.tick()`, call `patchBounds` right after `patchTransforms`:

```typescript
if (state && state.entityIds && this.immediateState.count > 0) {
    this.immediateState.patchTransforms(state.transforms, state.entityIds, state.entityCount);
    this.immediateState.patchBounds(state.bounds, state.entityIds, state.entityCount);
}
```

### Testing

- New test: `patchBounds modifies bounds buffer at correct offsets` — verifies xyz patched, radius preserved
- Update existing test at `immediate-state.test.ts:123`: the ray at the new position should now HIT (desync is fixed)
- Verify that entities NOT in the override map are unaffected

### Impact

- **TS only**: `immediate-state.ts`, `hyperion.ts`, `immediate-state.test.ts`
- **No Rust changes**
- Remove "CPU picking uses bounds, not transforms" gotcha from `CLAUDE.md` and `PROJECT_ARCHITECTURE.md`

---

## Fix 3: Ring-Buffer Driven Audio Listener

### Problem

The audio listener position is updated from `cameraApi.x/y` in `Hyperion.tick()`, which runs at RAF rate. During main-thread jank (GC pause, heavy DOM), RAF stalls, the listener position freezes, and spatial audio goes out of sync with entity positions that kept advancing in the worker simulation.

### Design

Route the camera position through the ring buffer → WASM → render state, so the Worker can extrapolate the listener position during jank at the fixed 60Hz tick rate.

#### Data Flow (new)

```
TS tick():
  1. Send SetListenerPosition(camera.x, camera.y, 0) via ring buffer
                                    │
                                    ▼
                          SharedArrayBuffer
                                    │
                                    ▼
                      WASM engine_update():
                        process_commands() reads SetListenerPosition
                        Computes velocity: vel = (pos - prev_pos) / dt
                        Per physics tick: listener_pos += listener_vel * dt
                                    │
                                    ▼
                      Render state includes listener_x, listener_y
                                    │
TS tick():                          │
  3. Read listener position from render state
  4. audioManager.setListenerPosition(state.listenerX, state.listenerY)
     Uses setTargetAtTime() for smooth pan/gain transitions
```

#### Rust Changes

**Ring buffer** (`ring_buffer.rs`):
- New command: `SetListenerPosition = 13`
- Payload: `x: f32, y: f32, z: f32` = 12 bytes (4 bytes spare for future flags)
- `payload_size()` returns 12

**Engine** (`engine.rs`):
- New fields on `Engine`:
  ```rust
  listener_pos: [f32; 3],      // current extrapolated position
  listener_prev_pos: [f32; 3], // previous frame's position (for velocity derivation)
  listener_vel: [f32; 3],      // derived velocity
  ```
- In the fixed-timestep loop, advance per tick:
  ```rust
  for i in 0..3 {
      self.listener_pos[i] += self.listener_vel[i] * dt;
  }
  ```
- When `SetListenerPosition` is processed:
  ```rust
  let new_pos = [x, y, z]; // from command payload
  self.listener_vel = [
      (new_pos[0] - self.listener_prev_pos[0]) / dt,
      (new_pos[1] - self.listener_prev_pos[1]) / dt,
      (new_pos[2] - self.listener_prev_pos[2]) / dt,
  ];
  self.listener_pos = new_pos;
  self.listener_prev_pos = new_pos;
  ```
- Accessors: `listener_x() -> f32`, `listener_y() -> f32`, `listener_z() -> f32`

**WASM exports** (`lib.rs`):
- `engine_listener_x() -> f32`
- `engine_listener_y() -> f32`
- `engine_listener_z() -> f32`

#### TypeScript Changes

**Ring buffer** (`ring-buffer.ts`):
- `CommandType.SetListenerPosition = 13`, payload size 12
- Helper: `setListenerPosition(x: number, y: number, z: number): boolean`

**Backpressure** (`backpressure.ts`):
- `SetListenerPosition` is an overwrite command (latest-value-per-entity with entity 0 as sentinel key), not critical

**Worker bridge** (`worker-bridge.ts`):
- Extend `GPURenderState` with `listenerX: number, listenerY: number, listenerZ: number`
- Read from WASM exports `engine_listener_x()/y()/z()` in bridge tick
- Update `engine-worker.ts` to read and transfer listener values

**Hyperion facade** (`hyperion.ts`):
- In `tick()`:
  ```typescript
  // Send camera position to WASM for extrapolation
  this.bridge.commandBuffer.setListenerPosition(this.cameraApi.x, this.cameraApi.y, 0);

  // Read WASM-extrapolated listener position from render state
  const state = this.bridge.latestRenderState;
  if (state && this.audioManager.isInitialized) {
      this.audioManager.setListenerPosition(state.listenerX, state.listenerY);
  }
  ```
- Remove the old direct `cameraApi.x/y` → `setListenerPosition` call

**PlaybackEngine** (`playback-engine.ts`):
- In `applySpatial()`, use `setTargetAtTime` with anchor pattern:
  ```typescript
  const now = this.ctx.currentTime;
  const TAU = 0.015; // 15ms time constant

  // Anchor current value to avoid discontinuity
  playback.panner.pan.setValueAtTime(playback.panner.pan.value, now);
  // Exponential approach to target
  playback.panner.pan.setTargetAtTime(newPan, now, TAU);

  // Same for gain (distance attenuation)
  playback.gain.gain.setValueAtTime(playback.gain.gain.value, now);
  playback.gain.gain.setTargetAtTime(newGain, now, TAU);
  ```

#### 3D Forward-Compatibility

- `SetListenerPosition` sends `(x, y, z)` — z=0 for 2D, nonzero for future 3D
- Future `SetListenerOrientation` command (quaternion = 16 bytes) follows the `SetPrimParams0/1` split pattern
- When 3D camera is introduced, swap `StereoPannerNode` for native `PannerNode` + `AudioListener` — same WASM exports, TS-only refactor

### Testing

**Rust**:
- `SetListenerPosition` command parsing (12-byte payload)
- Velocity derivation from position delta
- Listener position extrapolation over multiple ticks
- Initial state: listener at origin, zero velocity

**TypeScript**:
- `SetListenerPosition` command type synced in ring buffer
- `GPURenderState` includes listener fields
- `setTargetAtTime` called (not direct `.value =` assignment)
- Hyperion tick sends listener position and reads from render state

### Impact

- **Rust**: `ring_buffer.rs`, `engine.rs`, `command_processor.rs`, `lib.rs`
- **TypeScript**: `ring-buffer.ts`, `backpressure.ts`, `worker-bridge.ts`, `engine-worker.ts`, `hyperion.ts`, `playback-engine.ts`
- **Test files**: Ring buffer tests (Rust + TS), engine tests, playback-engine tests, hyperion tests

---

## Files Modified Summary

| File | Fix 1 | Fix 2 | Fix 3 |
|------|-------|-------|-------|
| `components.rs` | **X** | | |
| `command_processor.rs` | **X** | | **X** |
| `systems.rs` | **X** | | |
| `engine.rs` | | | **X** |
| `ring_buffer.rs` | | | **X** |
| `lib.rs` | | | **X** |
| `immediate-state.ts` | | **X** | |
| `hyperion.ts` | | **X** | **X** |
| `ring-buffer.ts` | | | **X** |
| `backpressure.ts` | | | **X** |
| `worker-bridge.ts` | | | **X** |
| `engine-worker.ts` | | | **X** |
| `playback-engine.ts` | | | **X** |
| `CLAUDE.md` | | **X** | **X** |
| `PROJECT_ARCHITECTURE.md` | **X** | **X** | **X** |

---

## Validation Checklist

- [ ] Entity with 33 children: all 33 have correct parent + propagated transforms
- [ ] OverflowChildren removed when last overflow child is unparented
- [ ] Children::remove() returns bool for found/not-found
- [ ] patchBounds patches xyz, preserves radius
- [ ] hitTestRay returns correct entity during immediate mode drag
- [ ] SetListenerPosition command parsed correctly (12-byte payload)
- [ ] Listener velocity derived from position delta in Rust
- [ ] Listener position extrapolated during multi-tick simulation
- [ ] setTargetAtTime used for pan/gain transitions (not direct .value assignment)
- [ ] Render state includes listenerX/Y/Z fields
- [ ] Hyperion.tick() sends listener via ring buffer, reads from render state
- [ ] All Rust tests pass: `cargo test -p hyperion-core`
- [ ] All TS tests pass: `cd ts && npm test`
- [ ] Type check passes: `cd ts && npx tsc --noEmit`
- [ ] Clippy clean: `cargo clippy -p hyperion-core`
- [ ] CLAUDE.md and PROJECT_ARCHITECTURE.md updated
